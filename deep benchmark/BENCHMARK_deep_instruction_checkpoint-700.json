[
  {
    "id": "abc301_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    n = int(input().strip())\n    s = input().strip()\n    \n    takahashi_wins = s.count('T')\n    aoki_wins = s.count('A')\n    \n    if takahashi_wins > aoki_wins:\n        print('T')\n    elif aoki_wins > takahashi_wins:\n        print('A')\n    else:\n        print('T')\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "id": "abc301_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    result = []\n    current = arr[:]\n    \n    while True:\n        found = False\n        for i in range(n - 1):\n            if abs(current[i] - current[i + 1]) == 1:\n                continue\n            \n            # Find closest neighbors with same sign\n            left = max(0, current[i] - 1)\n            right = min(100, current[i] + 1)\n            \n            best_diff = float('inf')\n            best_left = None\n            best_right = None\n            \n            for j in range(left, right + 1):\n                if abs(j - current[i + 1]) < best_diff:\n                    best_diff = abs(j - current[i + 1])\n                    best_left = j\n                    best_right = j\n            \n            if best_left is not None and best_right is not None:\n                result.extend([best_left, best_right])\n                current = current[:i + 1] + [best_left, best_right] + current[i + 1:]\n                found = True\n                break\n        \n        if not found:\n            break\n    \n    print(' '.join(map(str, current)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc302_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    A, B = map(int, input().split())\n    \n    if B == 0:\n        print(0)\n        return\n        \n    quotient = (A + B - 1) // B\n    remainder = (A + B - 1) % B\n    \n    if remainder >= 0:\n        result = quotient + 1\n    else:\n        result = quotient\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc303_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    \n    grid = []\n    idx = 2\n    for _ in range(m):\n        row = list(map(int, data[idx:idx+n]))\n        idx += n\n        grid.append(row)\n    \n    count = 0\n    for i in range(m):\n        for j in range(n):\n            current = grid[i][j]\n            # Check right neighbor\n            if j < n - 1 and grid[i][j+1] != current:\n                count += 1\n            # Check below neighbor\n            if i < m - 1 and grid[i+1][j] != current:\n                count += 1\n                \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc303_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    S = list(data[1].strip())\n    T = list(data[2].strip())\n    \n    for i in range(n):\n        s_char = S[i]\n        t_char = T[i]\n        \n        # Check if both characters are same\n        if s_char != t_char:\n            continue\n            \n        # Check condition for '1' vs 'l'\n        if s_char == '1' and t_char == 'l':\n            if ord(s_char) != ord(t_char):\n                print(\"No\")\n                return\n                \n        # Check condition for '0' vs 'o'\n        elif s_char == '0' and t_char == 'o':\n            if ord(s_char) != ord(t_char):\n                print(\"No\")\n                return\n                \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc304_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    \n    people = []\n    for i in range(1, n + 1):\n        parts = data[i].split()\n        name = parts[0]\n        age = int(parts[1])\n        people.append((name, age))\n    \n    # Sort by age descending\n    sorted_people = sorted(people, key=lambda x: -x[1])\n    \n    for person in sorted_people:\n        print(person[0])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc304_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    N = int(sys.stdin.readline().strip())\n    \n    if N <= 10**3 - 1:\n        print(N)\n    elif N <= 10**4 - 1:\n        print(str(N)[::-1][1:])\n    elif N <= 10**5 - 1:\n        print(str(N)[::-1][2:])\n    elif N <= 10**6 - 1:\n        print(str(N)[::-1][3:])\n    elif N <= 10**7 - 1:\n        print(str(N)[::-1][4:])\n    elif N <= 10**8 - 1:\n        print(str(N)[::-1][5:])\n    else:\n        print(str(N)[::-1][6:])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc305_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    N = int(input().strip())\n    if N <= 5:\n        print(50)\n    elif N <= 15:\n        print(40)\n    elif N <= 25:\n        print(30)\n    elif N <= 35:\n        print(20)\n    else:\n        print(10)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc305_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "p, q = input().split()\nif p == 'A':\n    if q == 'B':\n        print(6)\n    elif q == 'C':\n        print(4)\nelif p == 'B':\n    if q == 'A':\n        print(6)\n    elif q == 'C':\n        print(2)\nelif p == 'C':\n    if q == 'A':\n        print(4)\n    elif q == 'B':\n        print(2)\nelif p == 'D':\n    if q == 'A':\n        print(5)\n    elif q == 'B':\n        print(4)\nelif p == 'E':\n    if q == 'A':\n        print(1)\n    elif q == 'B':\n        print(3)\nelif p == 'F':\n    if q == 'A':\n        print(5)\n    elif q == 'B':\n        print(1)\nelif p == 'G':\n    if q == 'A':\n        print(9)\n    elif q == 'B':\n        print(8)"
  },
  {
    "id": "abc306_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    result = ''.join([char * 2 for char in s])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc306_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    digits = list(map(int, input().split()))\n    result = sum(d * (2 ** i) for i, d in enumerate(digits))\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc307_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    steps = list(map(int, data[1:1+n]))\n    \n    total_per_week = []\n    current_sum = 0\n    for step in steps:\n        current_sum += step\n        if len(total_per_week) < 7:\n            total_per_week.append(current_sum)\n        else:\n            # Remove the oldest value and add the new one\n            total_per_week.pop(0)\n            total_per_week.append(current_sum)\n    \n    print(' '.join(map(str, total_per_week)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc307_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    strings = data[1:1+n]\n    \n    max_len = 50\n    results = [False] * n\n    \n    for i in range(n):\n        s = strings[i]\n        m = len(s)\n        \n        # Check all possible starting positions\n        for start in range(m + 1):\n            # Check all possible ending positions\n            for end in range(start, min(start + max_len, m) + 1):\n                # Extract substring\n                substr = s[start:end]\n                \n                # If substring has odd length, check palindrome property\n                if (end - start) % 2 == 1:\n                    # For odd length, middle character should match\n                    if end - start == 1:\n                        if substr != substr[::-1]:\n                            continue\n                    else:\n                        mid_char = substr[(end - start) // 2]\n                        left_half = substr[:mid_char]\n                        right_half = substr[mid_char:]\n                        if left_half != right_half[::-1]:\n                            continue\n                \n                # Check if substring is palindrome\n                if substr == substr[::-1]:\n                    results[i] = True\n                    break\n        \n        if results[i]:\n            break\n    \n    print(\"Yes\" if any(results) else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc308_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    S = list(map(int, input().split()))\n    \n    # Check condition 1: Monotonic non-decreasing\n    if not all(S[i] <= S[i+1] for i in range(7)):\n        print(\"No\")\n        return\n        \n    # Check condition 2: All between 100 and 675\n    if not all(100 <= s <= 675 for s in S):\n        print(\"No\")\n        return\n        \n    # Check condition 3: All multiples of 25\n    if not all(s % 25 == 0 for s in S):\n        print(\"No\")\n        return\n        \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc308_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        print(0)\n        return\n        \n    n, m = map(int, data[0].split())\n    colors = data[1].split()\n    pairs = []\n    for i in range(m):\n        d = data[2 + i]\n        p = int(data[3 + i])\n        pairs.append((d, p))\n    \n    # Create mapping: color -> list of (pair_index, pair_value)\n    color_to_pairs = {}\n    for idx, (color, p) in enumerate(pairs):\n        if color not in color_to_pairs:\n            color_to_pairs[color] = []\n        color_to_pairs[color].append((idx, p))\n    \n    total_cost = 0\n    for c in colors:\n        if c in color_to_pairs:\n            for idx, p_val in color_to_pairs[c]:\n                total_cost += p_val\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc309_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    A, B = map(int, input().split())\n    result = \"Yes\" if abs(A - B) == 1 else \"No\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc309_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0])\n    grid = []\n    for i in range(1, 1 + n):\n        grid.append(list(map(int, data[i].strip())))\n    \n    # Create original grid as reference\n    result_grid = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            row.append(grid[i][j])\n        result_grid.append(row)\n    \n    # Shift outer squares clockwise by one\n    # First shift rightward (from outside to center)\n    for k in range(1, n):  # k=1 to n-1\n        for i in range(k, n - k):\n            # Top row\n            result_grid[k][n - k - 1] = grid[n - k - 1][n - k - 1]\n            \n            # Rightmost column\n            result_grid[n - k - 1][n - i - 1] = grid[n - k - 1][n - k - 2]\n            \n            # Bottom row\n            result_grid[n - i - 1][k] = grid[n - i - 1][n - k - 1]\n            \n            # Leftmost column\n            result_grid[n - i - 1][k - 1] = grid[n - i - 1][k - 1]\n    \n    # Then shift downward (from center to outside)\n    for k in range(1, n):  # k=1 to n-1\n        for i in range(k, n - k):\n            # Top row\n            result_grid[k - 1][n - i - 1] = grid[k - 1][n - i - 1]\n            \n            # Rightmost column\n            result_grid[k - 1][i] = grid[k - 1][n - i - 2]\n            \n            # Bottom row\n            result_grid[n - i - 1][i] = grid[n - i - 1][n - i - 2]\n            \n            # Leftmost column\n            result_grid[n - i - 1][k - 1] = grid[n - i - 1][k - 1]\n    \n    # Output the result\n    for i in range(n):\n        print(''.join(str(result_grid[i][j]) for j in range"
  },
  {
    "id": "abc310_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    P = int(data[1])\n    Q = int(data[2])\n    D = list(map(int, data[3:3+n]))\n    \n    min_cost = float('inf')\n    \n    # Case 1: Use coupon (dish costs Q)\n    cost_case1 = Q + P\n    \n    # Case 2: Don't use coupon (find minimum among all dishes)\n    for d in D:\n        if d < cost_case1:\n            cost_case1 = d\n            \n    min_cost = min(cost_case1, min_cost)\n    \n    print(min_cost)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc310_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    products = []\n    index = 2\n    for i in range(n):\n        p_val = int(data[index]); index += 1\n        c_val = int(data[index]); index += 1\n        \n        functions = list(map(int, data[index:index+c_val]))\n        index += c_val\n        \n        products.append((p_val, sorted(functions)))\n    \n    # Precompute gaps: for each function f, store minimum p_j where f_j < f\n    gaps = [[] for _ in range(m+1)]\n    for i in range(n):\n        p_val, functions = products[i]\n        for f in functions:\n            gaps[f].append(p_val)\n    \n    # Sort gaps by value\n    for g_list in gaps:\n        g_list.sort()\n    \n    # Find the first gap that contains any function\n    result = \"No\"\n    for f in range(1, m+1):\n        if gaps[f]:\n            result = \"Yes\"\n            break\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc311_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    count_A = 0\n    count_B = 0\n    count_C = 0\n    \n    result = 0\n    \n    for i, char in enumerate(s):\n        if char == 'A':\n            count_A += 1\n        elif char == 'B':\n            count_B += 1\n        else:  # char == 'C'\n            count_C += 1\n            \n        if count_A > 0 and count_B > 0 and count_C > 0:\n            result = i + 1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc311_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    \n    n, d = map(int, data[0].split())\n    schedules = []\n    for i in range(1, 1 + n):\n        schedules.append(data[i])\n    \n    max_count = 0\n    \n    for start_day in range(d):\n        count = 0\n        all_free = True\n        \n        for person_schedule in schedules:\n            # Check if this person has free days starting from start_day\n            free_days = 0\n            for day in range(start_day, min(start_day + d, d)):\n                if person_schedule[day] == 'o':\n                    free_days += 1\n            \n            if free_days > 0:\n                count += 1\n                if free_days > max_count:\n                    max_count = free_days\n            else:\n                all_free = False\n                break\n                \n        if all_free and count > max_count:\n            max_count = count\n            \n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc312_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    S = input().strip()\n    \n    # Create all possible combinations by swapping characters\n    combinations = [\n        (S[0], S[1], S[2]),  # original\n        (S[0], S[2], S[1]),  # A -> B, A -> D, A -> F\n        (S[0], S[1], S[2]),  # B -> A, B -> D, B -> F\n        (S[0], S[2], S[1]),  # D -> A, D -> B, D -> C\n        (S[1], S[0], S[2]),  # A -> C, A -> E, A -> G\n        (S[1], S[2], S[0]),  # C -> A, C -> E, C -> B\n        (S[1], S[0], S[2]),  # E -> C, E -> A, E -> F\n        (S[1], S[2], S[0]),  # F -> C, F -> B, F -> D\n        (S[2], S[0], S[1]),  # C -> B, C -> D, C -> E\n        (S[2], S[1], S[0]),  # B -> D, B -> E, B -> F\n        (S[2], S[0], S[1]),  # D -> E, D -> F, D -> C\n    ]\n    \n    for comb in combinations:\n        if ''.join(comb) == 'ACE' or \\\n           ''.join(comb) == 'BDF' or \\\n           ''.join(comb) == 'CEG' or \\\n           ''.join(comb) == 'DFA' or \\\n           ''.join(comb) == 'EBG' or \\\n           ''.join(comb) == 'FAC' or \\\n           ''.join(comb) == 'GBD':\n            print('Yes')\n            return\n    \n    print('No')\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "id": "abc312_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    n, m = map(int, data[0].split())\n    grid = []\n    for i in range(1, 1 + n):\n        grid.append(data[i])\n    \n    tak_code_cells = set()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                tak_code_cells.add((i, j))\n    \n    result = []\n    for i in range(n - 8):\n        for j in range(m - 8):\n            valid = True\n            for x in range(i, i + 9):\n                for y in range(j, j + 9):\n                    if (x, y) not in tak_code_cells:\n                        valid = False\n                        break\n                if not valid:\n                    break\n            if valid:\n                result.append(f\"{i} {j}\")\n    \n    print(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc313_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    programming_abilities = list(map(int, data[1:1+n]))\n    \n    min_needed = float('inf')\n    for p in programming_abilities:\n        if p < min_needed:\n            min_needed = p\n    \n    print(max(0, min_needed - 1))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc314_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    n = int(sys.stdin.readline().strip())\n    \n    # Precomputed string of first 101 digits of pi\n    pi_str = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n    \n    # Truncate to exactly n+1 characters (since we want N+1 decimal places)\n    result = pi_str[:n + 1]\n    \n    # Remove trailing zeros after decimal point\n    if '.' in result:\n        parts = result.split('.')\n        if len(parts) >= 2:\n            result = parts[0] + '.' + parts[1].rstrip('0')\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc314_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    bets = []\n    index = 1\n    for i in range(n):\n        c = int(data[index]); index += 1\n        arr = list(map(int, data[index:index+c]))\n        index += c\n        bets.append((c, arr))\n    \n    X = int(data[index]); index += 1\n    \n    result = []\n    for i in range(1, n + 1):\n        count = 0\n        found_valid = False\n        \n        for _, arr in bets:\n            if i - 1 < len(arr) and arr[i - 1] == X:\n                count += 1\n                found_valid = True\n        \n        if found_valid and count <= len(result) or not result:\n            result.append(i)\n    \n    print(len(result))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc315_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    M = int(data[0])\n    D_list = list(map(int, data[1:1+M]))\n    \n    total_days = sum(D_list)\n    half = (total_days + 1) // 2\n    \n    current_sum = 0\n    for month in range(M):\n        current_sum += D_list[month]\n        if current_sum >= half:\n            result_month = month + 1\n            result_day = half - current_sum + 1\n            print(f\"{result_month} {result_day}\")\n            return\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc315_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "S = input().strip()\nresult = ''.join(c for c in S if c not in 'aeiou')\nprint(result)"
  },
  {
    "id": "abc318_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    vertical_intervals = []\n    horizontal_intervals = []\n    \n    index = 1\n    for _ in range(n):\n        A = int(data[index]); B = int(data[index+1])\n        C = int(data[index+2]); D = int(data[index+3])\n        index += 4\n        \n        # Vertical intervals: (x, x)\n        vertical_intervals.append((A, A))\n        vertical_intervals.append((B, B))\n        \n        # Horizontal intervals: (y, y)\n        horizontal_intervals.append((C, C))\n        horizontal_intervals.append((D, D))\n    \n    # Extract all points and sort them\n    all_points = sorted(vertical_intervals + horizontal_intervals)\n    \n    # Count segments between consecutive points\n    segments = []\n    current_x = None\n    current_y = None\n    \n    for point in all_points:\n        if point[0] == current_x and point[1] == current_y:\n            continue\n            \n        if current_x is not None and current_y is not None:\n            segments.append((current_x, current_y))\n            \n        current_x, current_y = point\n        \n    # Add last segment if it exists\n    if current_x is not None and current_y is not None:\n        segments.append((current_x, current_y))\n    \n    # Group segments by x-coordinate\n    groups = {}\n    for start, end in segments:\n        if start not in groups:\n            groups[start] = []\n        groups[start].append(end)\n    \n    total_width = 0\n    total_height = 0\n    \n    for x, ends in groups.items():\n        min_end = min(ends)\n        max_end = max(ends)\n        width = max_end - x\n        height = min_end - x\n        total_width += width\n        total_height += height\n    \n    result = total_width * total_height\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc318_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    M = int(data[1])\n    P = int(data[2])\n    \n    if P == M:\n        print(0)\n        return\n        \n    g = math.gcd(M, P)\n    m = M // g\n    p = P // g\n    \n    count = (N - 1) // p + 1\n    result = count * m - (m - 1) // 2\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc319_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    N = int(input().strip())\n    \n    result = []\n    max_divisor = min(9, N + 1)\n    \n    for i in range(N + 1):\n        found = False\n        \n        # Check all possible divisors up to max_divisor\n        for d in range(1, max_divisor + 1):\n            if N % d == 0:\n                k = N // d\n                if i % k == 0:\n                    result.append(str(d))\n                    found = True\n                    break\n        \n        if not found:\n            result.append('-')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc320_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    s = input().strip()\n    n = len(s)\n    \n    # Precompute prefix palindromes: p[i][j] = true if s[i:j+1] is palindrome\n    p = [[False] * n for _ in range(n)]\n    \n    max_length = 0\n    \n    # Fill the diagonal (single characters)\n    for i in range(n):\n        p[i][i] = True\n        max_length = 1\n    \n    # Fill the 2x2 squares\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            p[i][i + 1] = True\n            max_length = 2\n    \n    # Fill the rest of the table\n    for length in range(3, n + 1):  # lengths from 3 to n\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j] and p[i + 1][j - 1]:\n                p[i][j] = True\n                max_length = length\n    \n    print(max_length)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc320_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    A, B = map(int, input().split())\n    result = pow(A, B) + pow(B, A)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc321_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    N = int(data[0])\n    X = int(data[1])\n    \n    scores = list(map(int, data[2:2+N-1]))\n    \n    # Sort all scores including the new one\n    all_scores = sorted(scores + [None])\n    \n    # Calculate cumulative sums\n    cum_sums = []\n    current_sum = 0\n    for score in all_scores:\n        if score is None:\n            cum_sums.append(current_sum)\n        else:\n            current_sum += score\n    \n    # Find indices of top N-2 elements\n    top_indices = []\n    for idx, val in enumerate(all_scores):\n        if val is not None:\n            top_indices.append(idx)\n    \n    top_n2 = [all_scores[i] for i in top_indices]\n    \n    # Sort top N-2 elements\n    top_n2_sorted = sorted(top_n2)\n    \n    # Calculate required minimum\n    if len(top_n2_sorted) == 0:\n        result = -1\n    elif len(top_n2_sorted) == 1:\n        result = max(0, top_n2_sorted[0] - X)\n    else:\n        min_grade = top_n2_sorted[0] + top_n2_sorted[1]\n        if min_grade >= X:\n            result = min(0, top_n2_sorted[0] - X)\n        else:\n            result = max(0, top_n2_sorted[-1] - X)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc321_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    n_str = str(n)\n    for i in range(len(n_str) - 1):\n        if int(n_str[i]) <= int(n_str[i + 1]):\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    main()"
  },
  {
    "id": "abc322_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    N = int(data[0])\n    S = data[1].strip()\n    \n    for i in range(N - 2):\n        if S[i:i+3] == \"ABC\":\n            print(i + 1)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc322_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n, m = map(int, data[0].split())\n    s = data[1]\n    t = data[2]\n    \n    if s == t[:n]:\n        print(0)\n    elif s == t[-n:]:\n        print(1)\n    else:\n        print(3)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc323_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    \n    players = []\n    for i in range(1, n + 1):\n        s = data[i]\n        wins = 0\n        losses = 0\n        draws = 0\n        \n        for j in range(n):\n            if s[j] == 'o':\n                wins += 1\n            elif s[j] == 'x':\n                losses += 1\n            else:  # s[j] == '-'\n                draws += 1\n                \n        players.append((wins, losses, i))\n    \n    players.sort(key=lambda x: (-x[0], -x[1], x[2]))\n    \n    for score, _, idx in players:\n        print(idx)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc323_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    S = input().strip()\n    correct = True\n    for i in range(2, 17, 2):\n        if S[i] != '0':\n            correct = False\n            break\n    print(\"Yes\" if correct else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc324_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    first_value = int(data[1])\n    \n    for i in range(2, n + 1):\n        if int(data[i]) != first_value:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc324_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    N = int(input().strip())\n    \n    # Factorize N into prime factors\n    factors = {}\n    temp = N\n    \n    # Handle factor 2\n    while temp % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        temp //= 2\n    \n    # Check odd factors up to sqrt(N)\n    f = 3\n    while f * f <= temp:\n        while temp % f == 0:\n            factors[f] = factors.get(f, 0) + 1\n            temp //= f\n        f += 2\n    \n    # If temp is still greater than 1, it's a prime factor\n    if temp > 1:\n        factors[temp] = factors.get(temp, 0) + 1\n    \n    # Check conditions for each prime factor\n    result = \"No\"\n    for p, exp in factors.items():\n        if p == 2:\n            # For power of 2: exponent must be even\n            if exp % 2 != 0:\n                result = \"No\"\n        elif p == 3:\n            # For power of 3: exponent must be at least 1\n            if exp < 1:\n                result = \"No\"\n        else:\n            # For other primes: exponent must be divisible by their exponent\n            if exp % (p - 1) != 0:\n                result = \"No\"\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc325_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "S = input().strip()\nT = input().strip()\nprint(f\"{S} {T} san\")"
  },
  {
    "id": "abc326_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    N = int(input().strip())\n    \n    # Find the rightmost digit that can be increased\n    for i in range(2, -1, -1):\n        if (N // (10 ** i)) % 10 < 9:\n            # Increment this digit\n            new_number = N + (10 ** i)\n            print(new_number)\n            return\n    \n    # If no digit can be incremented, it means we need to carry over\n    # But since we're looking for >= N, this should never happen with constraints\n    # However, just in case...\n    print(N)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc326_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    X, Y = map(int, input().split())\n    \n    # Calculate absolute difference\n    diff = abs(X - Y)\n    \n    # Check conditions\n    if diff <= 3:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc327_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "n = int(input().strip())\ns = input().strip()\n\nfound = False\nfor i in range(n - 1):\n    if s[i] == 'a' and s[i + 1] == 'b':\n        found = True\n    elif s[i] == 'b' and s[i + 1] == 'a':\n        found = True\n        \nprint(\"Yes\" if found else \"No\")"
  },
  {
    "id": "abc327_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    B = int(input().strip())\n    \n    if B < 4:\n        print(-1)\n        return\n        \n    # Find smallest d >= 2 where 4^(d/2) >= B\n    d = (int(math.ceil(math.sqrt(B)))) * 2\n    \n    while True:\n        candidate = 4 ** ((d + 1) // 2)\n        if candidate > B:\n            break\n        elif candidate == B:\n            print((d + 1) // 2)\n            return\n            \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc328_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    d_list = list(map(int, data[1:1+n]))\n    \n    count = 0\n    \n    # Check each month\n    for i in range(1, n + 1):\n        # Convert month number to string\n        month_str = str(i)\n        \n        # Iterate through all possible dates in this month\n        for j in range(1, d_list[i - 1] + 1):\n            # Convert day number to string\n            day_str = str(j)\n            \n            # Count frequency of each digit in both strings\n            freq_i = [0] * 10\n            freq_j = [0] * 10\n            \n            for char in month_str:\n                freq_i[int(char)] += 1\n                \n            for char in day_str:\n                freq_j[int(char)] += 1\n                \n            # Check if frequencies match\n            if freq_i == freq_j:\n                count += 1\n                \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc328_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    x = int(data[1])\n    scores = list(map(int, data[2:2+n]))\n    \n    count = 0\n    for s in scores:\n        if s <= x:\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc329_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "S = input().strip()\nfor char in S:\n    print(char, end=\"\")\nprint()"
  },
  {
    "id": "abc329_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    max_val = max(arr)\n    count_max = arr.count(max_val)\n    \n    result = None\n    for num in arr:\n        if num != max_val and arr.count(num) < count_max:\n            result = num\n            break\n            \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc330_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    L = int(data[1])\n    R = int(data[2])\n    \n    arr = list(map(int, data[3:3+n]))\n    \n    # Precompute min_abs_diffs\n    min_abs_diffs = [float('inf')] * (n + 1)\n    for i in range(n):\n        diff = abs(arr[i] - L)\n        if diff < min_abs_diffs[i]:\n            min_abs_diffs[i] = diff\n            \n        diff = abs(arr[i] - R)\n        if diff < min_abs_diffs[i]:\n            min_abs_diffs[i] = diff\n            \n    # Precompute max_abs_diffs\n    max_abs_diffs = [float('-inf')] * (n + 1)\n    for i in range(n):\n        diff = abs(arr[i] - L)\n        if diff > max_abs_diffs[i]:\n            max_abs_diffs[i] = diff\n            \n        diff = abs(arr[i] - R)\n        if diff > max_abs_diffs[i]:\n            max_abs_diffs[i] = diff\n            \n    result = []\n    for i in range(n):\n        candidate1 = arr[i] - min_abs_diffs[i]\n        candidate2 = arr[i] + min_abs_diffs[i]\n        \n        candidate3 = arr[i] - max_abs_diffs[i]\n        candidate4 = arr[i] + max_abs_diffs[i]\n        \n        candidates = [candidate1, candidate2, candidate3, candidate4]\n        candidates.sort()\n        result.append(candidates[R - L])\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc330_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    L = int(data[1])\n    scores = list(map(int, data[2:2+N]))\n    \n    count = 0\n    for score in scores:\n        if score >= L:\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc331_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    M = int(data[0])\n    D = int(data[1])\n    y = int(data[2])\n    m = int(data[3])\n    d = int(data[4])\n    \n    if d < D:\n        next_day = d + 1\n    else:\n        next_day = 1\n        if m < M:\n            next_month = m + 1\n        else:\n            next_month = 1\n            next_year = y + 1\n    \n    print(f\"{next_year} {next_month} {next_day}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc331_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = int(data[1])\n    M = int(data[2])\n    L = int(data[3])\n    \n    # Precompute cost for k packs of 12 (L/k)\n    packs_12_cost = [float('inf')] * (N + 1)\n    packs_12_cost[0] = 0\n    \n    for k in range(1, N // 12 + 2):\n        packs_12_cost[k * 12] = min(packs_12_cost[k * 12], L / k)\n    \n    # Precompute cost for k packs of 8 (M/(k+2))\n    packs_8_cost = [float('inf')] * (N + 1)\n    packs_8_cost[0] = 0\n    \n    for k in range(1, N // 8 + 2):\n        packs_8_cost[k * 8] = min(packs_8_cost[k * 8], M / (k + 2))\n    \n    # Precompute cost for k packs of 6 (S/(k+1))\n    packs_6_cost = [float('inf')] * (N + 1)\n    packs_6_cost[0] = 0\n    \n    for k in range(1, N // 6 + 2):\n        packs_6_cost[k * 6] = min(packs_6_cost[k * 6], S / (k + 1))\n    \n    # DP table: dp[i][j] = min cost to have i eggs with j packs of 12\n    dp = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n    \n    for i in range(0, N + 1):\n        for j in range(0, N + 1):\n            if dp[i][j] == float('inf'):\n                continue\n                \n            # Try adding one pack of 12\n            if i + 12 <= N:\n                dp[i + 12][j + 1] = min(dp[i + 12][j + 1], dp[i][j] + packs_12_cost[i + 12])\n            \n            # Try adding one pack of"
  },
  {
    "id": "abc332_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    S = int(data[1])\n    K = int(data[2])\n    \n    products = []\n    idx = 3\n    for i in range(n):\n        p = int(data[idx])\n        q = int(data[idx + 1])\n        idx += 2\n        products.append((p, q))\n    \n    total_price = 0\n    for p, q in products:\n        total_price += p * q\n    \n    if total_price >= S:\n        shipping_fee = 0\n    else:\n        shipping_fee = K\n    \n    result = total_price + shipping_fee\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc332_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    K = int(data[0])\n    G = int(data[1])\n    M = int(data[2])\n    \n    glass = 0\n    mug = 0\n    \n    for _ in range(K):\n        if glass < G:\n            # Glass not full: can't add more water\n            if mug > 0:\n                # Move some water from mug to glass\n                if mug >= (G - glass):\n                    # Can take all from mug\n                    glass += G - glass\n                    mug -= (G - glass)\n                else:\n                    # Take only what's in mug\n                    glass += mug\n                    mug = 0\n            else:\n                # Mug is empty, refill it\n                mug = M\n                \n        elif glass == G:\n            # Glass already full, discard all\n            glass = 0\n            \n        else:  # glass > G\n            # Glass overflowed, need to remove excess\n            if mug > 0:\n                # Move water from mug to glass until glass is full\n                if mug >= (G - glass):\n                    # Can take all from mug\n                    glass += (G - glass)\n                    mug -= (G - glass)\n                else:\n                    # Take only what's in mug\n                    glass += mug\n                    mug = 0\n                    \n            else:\n                # Mug is empty, refill it\n                mug = M\n                \n    print(f\"{glass} {mug}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc333_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    s1, s2 = data[0].strip(), data[1].strip()\n    t1, t2 = data[2].strip(), data[3].strip()\n    \n    # Pentagon vertices: A=0, B=1, C=2, D=3, E=4\n    # Convert letters to vertex indices (0=A, 1=B, ..., 4=E)\n    def get_vertex(s):\n        return {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}[s]\n    \n    S1, S2 = get_vertex(s1[0]), get_vertex(s1[1])\n    T1, T2 = get_vertex(t1[0]), get_vertex(t1[1])\n    \n    # Calculate distances using coordinates\n    # Coordinates for pentagon with center at origin, radius 1\n    # We'll use a simplified approach by checking if distances are close\n    \n    # Pentagonal vertices' complex coordinates\n    vertices = {\n        0: (1+0j),   # A\n        1: (0.5625+0.809017*j),  # B\n        2: (-0.625-0.585231j), # C\n        3: (-0.5+0j),         # D\n        4: (0.5-0j)           # E\n    }\n    \n    def distance(z1, z2):\n        return abs(z1 - z2)\n    \n    dist_S1_S2 = distance(vertices[S1], vertices[S2])\n    dist_T1_T2 = distance(vertices[T1], vertices[T2])\n    \n    # Check if they're very close (within 1e-9)\n    if round(dist_S1_S2, 9) == round(dist_T1_T2, 9):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc333_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    N = int(input().strip())\n    result = str(N) * N\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc334_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "B, G = map(int, input().split())\nif B > G:\n    print(\"Bat\")\nelse:\n    print(\"Glove\")"
  },
  {
    "id": "abc335_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "S = input().strip()\nprint(S[:-1] + '4')"
  },
  {
    "id": "abc335_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    N = int(input().strip())\n    \n    for x in range(N + 1):\n        for y in range(N - x + 1):\n            z = N - x - y\n            print(f\"{x} {y} {z}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc336_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    N = int(input().strip())\n    result = \"D\" + \"o\" * N + \"n\" + \"g\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc336_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    N = int(input().strip())\n    \n    if N == 0:\n        print(0)\n        return\n        \n    # Convert to binary string and remove '0b' prefix\n    bin_str = bin(N)[2:]\n    \n    # Find first non-zero character\n    for i, char in enumerate(bin_str):\n        if char != '0':\n            print(i)\n            break\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc337_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    S = input().strip()\n    \n    # Check if all characters are 'A'\n    if any(c != 'A' for c in S):\n        print(\"No\")\n        return\n    \n    # Check if all characters are 'B'\n    if any(c != 'B' for c in S):\n        print(\"No\")\n        return\n    \n    # Check if all characters are 'C'\n    if any(c != 'C' for c in S):\n        print(\"No\")\n        return\n    \n    # Check if string contains at least one 'A'\n    if 'A' not in S:\n        print(\"No\")\n        return\n    \n    # Check if string contains at least one 'B'\n    if 'B' not in S:\n        print(\"No\")\n        return\n    \n    # Check if string contains at least one 'C'\n    if 'C' not in S:\n        print(\"No\")\n        return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc337_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    takahashi_score = 0\n    aoki_score = 0\n    \n    for i in range(1, n + 1):\n        x = int(data[2 * i - 1])\n        y = int(data[2 * i])\n        takahashi_score += x\n        aoki_score += y\n        \n    if takahashi_score > aoki_score:\n        print(\"Takahashi\")\n    elif takahashi_score < aoki_score:\n        print(\"Aoki\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc338_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    S = input().strip()\n    \n    if S[0].isupper() and all(char.islower() for char in S[1:]):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc338_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    S = sys.stdin.readline().strip()\n    \n    freq = {}\n    for char in S:\n        freq[char] = freq.get(char, 0) + 1\n    \n    max_freq = max(freq.values(), default=0)\n    candidates = [char for char, count in freq.items() if count == max_freq]\n    \n    # Sort candidates by their ASCII values to get lexicographical order\n    candidates.sort()\n    \n    print(candidates[0])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc339_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "S = input().strip()\nparts = S.split('.')\nprint(parts[-1])"
  },
  {
    "id": "abc340_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n_queries = int(data[0])\n    queries = []\n    for i in range(n_queries):\n        queries.append((int(data[i*2+1]), int(data[i*2+2])))\n    \n    stack = []\n    results = []\n    \n    for op, val in queries:\n        if op == 1:\n            stack.append(val)\n        else:\n            # Get element at position val (k-th from end)\n            pos = len(stack) - val + 1\n            results.append(str(stack[pos-1]))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc340_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    A, B, D = map(int, input().split())\n    \n    if D == 0:\n        print(A)\n    else:\n        n = (B - A) // D + 1\n        first_term = A\n        last_term = first_term + (n - 1) * D\n        print(' '.join(str(i) for i in range(first_term, last_term + 1)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc341_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    A = list(map(int, data[1:1+n]))\n    S = []\n    T = []\n    idx = n + 1\n    for i in range(n):\n        s_val = int(data[idx]); t_val = int(data[idx+1])\n        idx += 2\n        S.append(s_val)\n        T.append(t_val)\n    \n    # Precompute prefix sums for A\n    prefix_A = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_A[i] = prefix_A[i-1] + A[i-1]\n    \n    # Sort by S descending\n    pairs = [(s, t) for s, t in zip(S, T)]\n    pairs.sort(key=lambda x: -x[0])\n    \n    total_gain = 0\n    current_sum = 0\n    \n    for s_val, t_val in pairs:\n        # Check if we can get more than t_val units with current sum\n        if t_val <= current_sum:\n            continue\n            \n        # Find the minimum k such that prefix_A[k] >= current_sum + t_val\n        low, high = 0, n\n        while low < high:\n            mid = (low + high) // 2\n            if prefix_A[mid] < current_sum + t_val:\n                low = mid + 1\n            else:\n                high = mid\n        \n        # Update current_sum\n        current_sum = prefix_A[high] + t_val\n        total_gain += t_val\n    \n    print(total_gain)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc341_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "n = int(input().strip())\nprint('1' + '0' * n)"
  },
  {
    "id": "abc342_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "S = input().strip()\nfirst_char = S[0]\nother_chars = [char for char in S if char != first_char]\nresult = other_chars.index(first_char) + 1\nprint(result)"
  },
  {
    "id": "abc342_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    persons = list(map(int, data[1:1+n]))\n    q = int(data[1+n])\n    \n    # Initialize positions - initially all people are at position 1\n    positions = [1] * n\n    \n    results = []\n    idx = 1 + n + 1\n    for _ in range(q):\n        a = int(data[idx]); b = int(data[idx+1]); idx += 2\n        if a == b:\n            results.append(str(persons[a-1]))\n        else:\n            # Find the minimum position between a and b\n            min_pos = float('inf')\n            for i in range(n):\n                if a <= persons[i] <= b:\n                    pos = positions[i]\n                    if pos < min_pos:\n                        min_pos = pos\n            \n            results.append(str(min_pos))\n        \n        # Update positions\n        for i in range(n):\n            if persons[i] >= a and persons[i] <= b:\n                positions[i] = min(positions[i], min_pos)\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc343_a",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    A, B = map(int, input().split())\n    result = None\n    \n    for num in range(0, 10):\n        if num != A + B:\n            result = num\n            break\n            \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc343_b",
    "model": "deep_instruction_checkpoint-700",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    adj_matrix = []\n    index = 1\n    for _ in range(n):\n        row = list(map(int, data[index:index+n]))\n        index += n\n        adj_matrix.append(row)\n    \n    result = []\n    for i in range(n):\n        connected = [str(j+1) for j, val in enumerate(adj_matrix[i]) if val == 1]\n        result.append(' '.join(connected))\n    \n    print('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  }
]