[
  {
    "id": "abc301_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    s = data[1]\n    \n    takahashi_wins = 0\n    aoki_wins = 0\n    \n    for i, char in enumerate(s):\n        if char == 'T':\n            takahashi_wins += 1\n        else:\n            aoki_wins += 1\n            \n    if takahashi_wins > aoki_wins:\n        print('T')\n    elif aoki_wins > takahashi_wins:\n        print('A')\n    else:\n        # If equal, we need to check which player reached the maximum first\n        max_wins = max(takahashi_wins, aoki_wins)\n        \n        # Check if Takahashi reached max_wins first\n        if takahashi_wins >= max_wins and (aoki_wins < max_wins or i - takahashi_wins < i - aoki_wins):\n            print('T')\n        else:\n            print('A')\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc301_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    A = list(map(int, data[1:1+N]))\n    \n    while True:\n        found = False\n        for i in range(N - 1):\n            if abs(A[i] - A[i + 1]) != 1:\n                continue\n                \n            left = max(1, A[i] - 1)\n            right = min(100, A[i + 1] + 1)\n            \n            for x in range(left, right + 1):\n                new_seq = A[:i] + [x] + A[i + 1:]\n                if all(abs(a - b) == 1 for a, b in zip(new_seq[:-1], new_seq[1:])):\n                    A = new_seq\n                    found = True\n                    break\n                    \n            if found:\n                break\n                \n        if not found:\n            break\n            \n    print(' '.join(map(str, A)))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "id": "abc302_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    A = int(data[0])\n    B = int(data[1])\n    \n    if B >= A:\n        print(0)\n        return\n        \n    count = 0\n    while True:\n        A -= B\n        count += 1\n        if A <= 0:\n            break\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc303_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    grid = []\n    index = 2\n    for i in range(m):\n        row = list(map(int, data[index:index+n]))\n        index += n\n        grid.append(row)\n    \n    # Precompute prefix sums for each column\n    col_prefix = [[0] * (n+1) for _ in range(n)]\n    for j in range(n):\n        for i in range(1, m+1):\n            col_prefix[j][i] = col_prefix[j][i-1] + grid[i-1][j]\n    \n    count = 0\n    for i in range(1, m+1):\n        for j in range(i+1, m+1):\n            total = 0\n            for k in range(n):\n                left = col_prefix[k][i-1]\n                right = col_prefix[k][m] - col_prefix[k][j]\n                total += abs(left - right)\n            count += total // 2\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc303_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index]); index += 1\n        s = data[index]; index += 1\n        t = data[index]; index += 1\n        \n        # Check if lengths match\n        if len(s) != len(t):\n            print(\"No\")\n            continue\n            \n        # Count mismatches\n        mismatch_count = 0\n        for i in range(n):\n            char_s = s[i]\n            char_t = t[i]\n            \n            # Check similarity based on character types\n            if char_s == char_t:\n                continue\n                \n            # Convert to digit or letter type\n            type_s = 'digit' if char_s.isdigit() else 'letter'\n            type_t = 'digit' if char_t.isdigit() else 'letter'\n            \n            # Similarity rules\n            if type_s == 'digit':\n                if type_t == 'digit':\n                    if abs(int(char_s)) == abs(int(char_t)):\n                        continue\n                elif type_t == 'letter':\n                    if char_s == 'o' and char_t == 'l':\n                        continue\n                    elif char_s == 'l' and char_t == 'o':\n                        continue\n            else:  # type_s == 'letter'\n                if type_t == 'letter':\n                    if char_s == char_t:\n                        continue\n                elif type_t == 'digit':\n                    if char_s == 'o' and char_t == 'l':\n                        continue\n                    elif char_s == 'l' and char_t == 'o':\n                        continue\n            \n            mismatch_count += 1\n        \n        # If no mismatches, they're similar\n        if mismatch_count == 0:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc304_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    idx = 1\n    result = []\n    \n    for _ in range(N):\n        S = data[idx]\n        A = int(data[idx + 1])\n        idx += 2\n        \n        # Create dictionary mapping ages to names\n        age_to_name = {}\n        for i in range(1, N + 1):\n            age_to_name[A] = S\n            A += 1\n            \n        # Get the youngest person's name (age 0)\n        result.append(age_to_name[0])\n        \n        # Remove the youngest person from the dictionary\n        del age_to_name[0]\n        \n        # Reorder the remaining names in clockwise order\n        sorted_names = sorted(age_to_name.keys())\n        for age in sorted_names:\n            result.append(age_to_name[age])\n            \n    print(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc304_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    N = int(data)\n    \n    if N <= 10**3 - 1:\n        print(N)\n    elif N <= 10**4 - 1:\n        print(str(N)[0:-1])\n    elif N <= 10**5 - 1:\n        print(str(N)[0:-2])\n    elif N <= 10**6 - 1:\n        print(str(N)[0:-3])\n    elif N <= 10**7 - 1:\n        print(str(N)[0:-4])\n    elif N <= 10**8 - 1:\n        print(str(N)[0:-5])\n    else:\n        print(str(N)[0:-6])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc305_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    \n    # Calculate distances to each water station\n    distances = []\n    for i in range(1, 22):\n        distances.append(i * 5)\n    \n    # Find minimum distance (excluding starting point which is always 0 km)\n    min_dist = float('inf')\n    for dist in distances:\n        if dist > 0 and dist < min_dist:\n            min_dist = dist\n    \n    # If we're already at a water station, output 0\n    if N % 5 == 0:\n        print(0)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc305_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    p = data[0]\n    q = data[1]\n    \n    if p == \"A\":\n        if q == \"B\":\n            print(3)\n        elif q == \"C\":\n            print(1)\n        elif q == \"D\":\n            print(4)\n        elif q == \"E\":\n            print(1)\n        elif q == \"F\":\n            print(5)\n        else:  # q == \"G\"\n            print(9)\n            \n    elif p == \"B\":\n        if q == \"C\":\n            print(1)\n        elif q == \"D\":\n            print(4)\n        elif q == \"E\":\n            print(1)\n        elif q == \"F\":\n            print(5)\n        else:  # q == \"G\"\n            print(9)\n            \n    elif p == \"C\":\n        if q == \"D\":\n            print(4)\n        elif q == \"E\":\n            print(1)\n        elif q == \"F\":\n            print(5)\n        else:  # q == \"G\"\n            print(9)\n            \n    elif p == \"D\":\n        if q == \"E\":\n            print(1)\n        elif q == \"F\":\n            print(5)\n        else:  # q == \"G\"\n            print(9)\n            \n    elif p == \"E\":\n        if q == \"F\":\n            print(5)\n        else:  # q == \"G\"\n            print(9)\n            \n    elif p == \"F\":\n        if q == \"G\":\n            print(9)\n        else:  # q == \"A\" or \"B\"\n            print(10)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc306_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = data[1]\n    \n    result = []\n    for char in S:\n        result.append(char)\n        result.append(char)\n        \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc306_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    A = list(map(int, data))\n    \n    result = 0\n    for i, bit in enumerate(A):\n        power = 63 - i\n        result += bit * (1 << power)\n        \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc307_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    steps_list = list(map(int, data[1:]))\n    \n    total_steps_per_week = []\n    current_sum = 0\n    for i in range(0, len(steps_list), 7):\n        week_steps = steps_list[i:i+7]\n        week_total = sum(week_steps)\n        total_steps_per_week.append(week_total)\n        current_sum += week_total\n        \n    print(\" \".join(map(str, total_steps_per_week)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc307_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    strings = []\n    index = 1\n    for i in range(n):\n        s = data[index]\n        index += 1\n        strings.append(s)\n    \n    # Precompute prefix sums for each string\n    prefix_sum = [0] * n\n    for i in range(1, n):\n        prefix_sum[i] = prefix_sum[i-1] + len(strings[i])\n    \n    # Check all pairs (i, j) with i < j\n    for i in range(n):\n        for j in range(i+1, n):\n            # Concatenate S_i and S_j\n            total_len = prefix_sum[j] - prefix_sum[i]\n            if total_len % 2 != 0:\n                continue\n                \n            mid = total_len // 2\n            part1 = strings[i][mid:]\n            part2 = strings[j][:mid]\n            \n            if part1 == part2[::-1]:\n                print(\"Yes\")\n                return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc308_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    S = list(map(int, data))\n    \n    # Check monotonicity\n    if not all(S[i] <= S[i+1] for i in range(7)):\n        print(\"No\")\n        return\n        \n    # Check bounds\n    if any(x < 100 or x > 675 for x in S):\n        print(\"No\")\n        return\n        \n    # Check divisibility by 25\n    if any(x % 25 != 0 for x in S):\n        print(\"No\")\n        return\n        \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc308_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    colors = []\n    for i in range(N):\n        colors.append(data[2 + i])\n        \n    dishes = []\n    for i in range(M):\n        dishes.append(data[2 + N + i])\n        \n    prices = list(map(int, data[2 + N + M]))\n    \n    dish_to_price = {}\n    for i in range(M):\n        dish_to_price[dishes[i]] = prices[i]\n    \n    total = 0\n    for color in colors:\n        if color in dish_to_price:\n            total += dish_to_price[color]\n            \n    print(total)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc309_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    \n    # Create the 3x3 grid\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    \n    # Check horizontal adjacency\n    for i in range(3):\n        for j in range(2):\n            if (grid[i][j] == A and grid[i][j+1] == B) or (grid[i][j] == B and grid[i][j+1] == A):\n                print(\"Yes\")\n                return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc309_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    grid = []\n    index = 1\n    for i in range(N):\n        row = list(map(int, data[index:index+N]))\n        index += N\n        grid.append(row)\n    \n    # Create new grid to store shifted values\n    result = [[0] * N for _ in range(N)]\n    \n    # Shift top row\n    for j in range(N):\n        result[0][j] = grid[0][(j+1)%N]\n    \n    # Shift right column  \n    for i in range(1, N):\n        result[i][N-1] = grid[i-1][(N-1)+1]%N\n    \n    # Shift bottom row  \n    for j in range(N-1, -1, -1):\n        result[N-1][j] = grid[N-1][(N-1)-j]%N\n    \n    # Shift left column  \n    for i in range(N-2, -1, -1):\n        result[i][0] = grid[i+1][(N-1)-N]%N\n    \n    # Copy remaining interior cells\n    for i in range(1, N-1):\n        for j in range(1, N-1):\n            result[i][j] = grid[i][j]\n    \n    # Format output\n    for row in result:\n        print(''.join(str(x) for x in row))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc310_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    P = int(data[1])\n    Q = int(data[2])\n    \n    D = []\n    idx = 3\n    for i in range(N):\n        D.append(int(data[idx]))\n        idx += 1\n        \n    # Sort dishes by price descending\n    D.sort(reverse=True)\n    \n    min_total = float('inf')\n    \n    # Try ordering all dishes with coupon\n    for i in range(1, N + 1):\n        cost_with_coupon = Q * i\n        remaining_dishes = N - i\n        total_for_remaining = sum(D[:remaining_dishes]) * (P // Q)\n        total_cost = cost_with_coupon + total_for_remaining\n        if total_cost < min_total:\n            min_total = total_cost\n            \n    print(min_total)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc310_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    prices = []\n    functions = []\n    \n    idx = 2\n    for i in range(n):\n        p = int(data[idx]); idx += 1\n        c = int(data[idx]); idx += 1\n        f_list = list(map(int, data[idx:idx+c]))\n        idx += c\n        prices.append(p)\n        functions.append(f_list)\n    \n    # Precompute prefix sums for each product\n    prefix_sum = [0] * n\n    for i in range(n):\n        prefix_sum[i] = sum(functions[i])\n    \n    # Check all pairs\n    found = False\n    for i in range(n):\n        for j in range(i+1, n):\n            if prices[i] >= prices[j]:\n                continue\n                \n            # Check if j has all functions of i\n            if set(functions[i]).issubset(set(functions[j])):\n                found = True\n                break\n            \n            # Check if i has at least one function that j lacks\n            for func in functions[i]:\n                if func not in functions[j]:\n                    found = True\n                    break\n            \n            if found:\n                break\n        \n        if found:\n            break\n    \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc311_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    s = data[1]\n    \n    count_a = 0\n    count_b = 0\n    count_c = 0\n    \n    for char in s:\n        if char == 'A':\n            count_a += 1\n        elif char == 'B':\n            count_b += 1\n        else:  # char == 'C'\n            count_c += 1\n            \n        if count_a > 0 and count_b > 0 and count_c > 0:\n            print(n)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc311_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    d = int(data[1])\n    \n    schedules = []\n    idx = 2\n    for i in range(n):\n        schedules.append(data[idx:idx+d])\n        idx += d\n        \n    # Precompute prefix sums for each person\n    prefix = [[0] * (d+1) for _ in range(n)]\n    for i in range(n):\n        for j in range(d):\n            prefix[i][j+1] = prefix[i][j] + (1 if schedules[i][j] == 'o' else 0)\n            \n    max_days = 0\n    \n    # Try all starting positions\n    for start in range(d):\n        # Try all lengths up to min(D, remaining days)\n        for length in range(1, min(d, d - start)):\n            valid = True\n            for i in range(n):\n                # Check if this person's prefix sum covers the entire segment\n                if prefix[i][start + length] != prefix[i][start]:\n                    valid = False\n                    break\n            if valid:\n                max_days = max(max_days, length)\n                \n    print(max_days)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc312_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    s = input().strip()\n    \n    # Check all possible rotations\n    for i in range(3):\n        rotated = s[i:] + s[:i]\n        \n        # Check if this rotation matches any target\n        if rotated == \"ACE\" or rotated == \"BDF\" or rotated == \"CEG\" or \\\n           rotated == \"DFA\" or rotated == \"EGB\" or rotated == \"FAC\" or rotated == \"GBD\":\n            print(\"Yes\")\n            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc312_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    m = int(data[1])\n    \n    grid = []\n    idx = 2\n    for i in range(n):\n        row = list(data[idx])\n        idx += 1\n        grid.append(row)\n    \n    def is_tak_code(i, j):\n        # Check top-left 3x3\n        if grid[i][j] != '#':\n            return False\n        if grid[i+1][j] != '#' or grid[i+2][j] != '#':\n            return False\n        if grid[i][j+1] != '.' or grid[i][j+2] != '.' or \\\n           grid[i+1][j+1] != '.' or grid[i+1][j+2] != '.' or \\\n           grid[i+2][j+1] != '.' or grid[i+2][j+2] != '.':\n            return False\n        \n        # Check bottom-right 3x3  \n        if grid[i][j] != '#':\n            return False\n        if grid[i+1][j] != '#' or grid[i+2][j] != '#':\n            return False\n        if grid[i][j+1] != '.' or grid[i][j+2] != '.' or \\\n           grid[i+1][j+1] != '.' or grid[i+1][j+2] != '.' or \\\n           grid[i+2][j+1] != '.' or grid[i+2][j+2] != '.':\n            return False\n        \n        # Check adjacency between top-left and bottom-right\n        for di in [-1, 0, 1]:\n            for dj in [-1, 0, 1]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < m:\n                    if grid[ni][nj] == '#':\n                        return False\n        \n        return True\n    \n    result = []\n    for i in range(n - 8):\n        for j in range(m - 8):\n            if is_tak_code(i, j):\n                result.append(f\"{i} {j}\")\n    \n    print(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc313_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    scores = list(map(int, data[1:1+n]))\n    \n    min_score = min(scores)\n    result = max(0, min_score - scores[0])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc314_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    \n    # Precomputed digits for pi up to 100 decimal places\n    pi_digits = [\n        \"3\", \"1\", \"4\", \"1\", \"5\",\n        \"9\", \"2\", \"6\", \"5\", \"3\",\n        \"5\", \"8\", \"9\", \"7\", \"9\",\n        \"3\", \"2\", \"3\", \"8\", \"4\",\n        \"6\", \"2\", \"6\", \"4\", \"3\",\n        \"3\", \"8\", \"3\", \"2\", \"7\",\n        \"9\", \"5\", \"0\", \"2\", \"8\",\n        \"8\", \"4\", \"1\", \"9\", \"7\",\n        \"0\", \"1\", \"6\", \"9\", \"3\",\n        \"7\", \"9\", \"9\", \"3\", \"7\",\n        \"5\", \"1\", \"0\", \"5\", \"8\",\n        \"2\", \"0\", \"9\", \"8\", \"6\",\n        \"2\", \"0\", \"8\", \"9\", \"9\"\n    ]\n    \n    # Truncate to N decimal places\n    truncated_str = ''.join(pi_digits[:N+1])\n    \n    # Remove trailing zeros\n    while len(truncated_str) > 1 and truncated_str[-1] == '0':\n        truncated_str = truncated_str[:-1]\n    \n    print(truncated_str)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc314_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    bets = []\n    index = 1\n    for i in range(N):\n        C_i = int(data[index]); index += 1\n        A_i = list(map(int, data[index:index+C_i]))\n        index += C_i\n        bets.append(A_i)\n    \n    X = int(data[index]); index += 1\n    \n    # Count how many people have bet on each number\n    num_bets = [0] * 38\n    for A in bets:\n        for num in A:\n            num_bets[num] += 1\n    \n    # Find the minimum number of bets\n    min_bets = float('inf')\n    for count in num_bets:\n        if count > 0 and count < min_bets:\n            min_bets = count\n    \n    # Collect indices of numbers with this minimum number of bets\n    result_indices = []\n    for i in range(37):\n        if num_bets[i] == min_bets:\n            result_indices.append(i+1)  # Convert to 1-based indexing\n    \n    # Sort the indices in ascending order\n    result_indices.sort()\n    \n    # Output the results\n    print(min_bets)\n    print(' '.join(map(str, result_indices)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc315_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    M = int(data[0])\n    D = list(map(int, data[1:1+M]))\n    \n    total_days = sum(D)\n    if total_days % 2 == 0:\n        # For even total days, we need to adjust\n        # Let's check if there's any way to get an odd total with the given constraints\n        # Actually, for the given constraints, we can always find a solution\n        pass\n    \n    # Find the middle day\n    mid_day_index = (total_days + 1) // 2 - 1\n    current_sum = 0\n    result_month = 1\n    result_day = 1\n    \n    for i in range(M):\n        current_sum += D[i]\n        if current_sum >= mid_day_index:\n            result_month = i + 1\n            result_day = mid_day_index - current_sum + 1\n            break\n    \n    print(f\"{result_month} {result_day}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc315_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    S = data[0].strip()\n    \n    vowels = set('aeiou')\n    result = []\n    \n    for char in S:\n        if char not in vowels:\n            result.append(char)\n            \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc318_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    sheets = []\n    index = 1\n    for i in range(n):\n        A = int(data[index]); B = int(data[index+1])\n        C = int(data[index+2]); D = int(data[index+3])\n        index += 4\n        sheets.append((A, B, C, D))\n    \n    # Precompute leftmost and rightmost x coordinates for each column\n    columns = [[] for _ in range(101)]\n    for A, B, C, D in sheets:\n        for x in range(A, B + 1):\n            columns[x].append((C, D))\n    \n    total_area = 0\n    for col in range(1, 101):\n        # Sort rectangles by right edge (x-coordinate)\n        rectangles = sorted(columns[col], key=lambda rect: rect[1])\n        \n        current_right = -1\n        current_bottom = -1\n        \n        for rect in rectangles:\n            C, D = rect\n            \n            # Check if this rectangle overlaps with existing ones\n            overlap = False\n            for prev_rect in rectangles:\n                prev_C, prev_D = prev_rect\n                \n                # Check if this rectangle is completely to the right of previous\n                if prev_C > C:\n                    continue\n                    \n                # Check if this rectangle is completely below previous\n                if prev_D < D:\n                    continue\n                    \n                # Check if there's any overlap\n                if max(prev_C, C) <= min(prev_D, D):\n                    overlap = True\n                    break\n            \n            if not overlap:\n                # This rectangle doesn't overlap with anything, so we add its area\n                width = C - current_right\n                height = D - current_bottom\n                total_area += width * height\n                current_right = C\n                current_bottom = D\n        \n        # If we had at least one rectangle, subtract the last one's area\n        if rectangles:\n            width = current_right - current_right\n            height = current_bottom - current_bottom\n            total_area -= width * height\n    \n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc318_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    M = int(data[1])\n    P = int(data[2])\n    \n    if M > N:\n        print(0)\n        return\n        \n    count = 0\n    current = M\n    \n    while current <= N:\n        if (current - M) % P == 0:\n            count += 1\n        current += 1\n        \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc319_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    \n    # Precompute all divisors of N\n    divisors = []\n    for i in range(1, 10):\n        if N % i == 0:\n            divisors.append(i)\n    \n    result = []\n    for i in range(N + 1):\n        found = False\n        for d in divisors:\n            if i % (N // d) == 0:\n                result.append(str(d))\n                found = True\n                break\n        if not found:\n            result.append(\"-\")\n    \n    print(\"\".join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc320_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    n = len(data)\n    \n    # Precompute prefix sums for each character\n    prefix_sum = [[0] * (n + 1) for _ in range(26)]\n    for i in range(n):\n        for char_idx in range(26):\n            if data[i] == chr(ord('A') + char_idx):\n                prefix_sum[char_idx][i+1] = prefix_sum[char_idx][i] + 1\n            else:\n                prefix_sum[char_idx][i+1] = prefix_sum[char_idx][i]\n    \n    max_len = 0\n    \n    # Try all possible lengths\n    for length in range(1, n // 2 + 1):\n        # Check all starting positions\n        for start in range(n - length + 1):\n            substr = data[start:start+length]\n            \n            # Check if this substring is a palindrome\n            left, right = 0, length - 1\n            while left < right:\n                if substr[left] != substr[right]:\n                    break\n                left += 1\n                right -= 1\n            else:\n                max_len = max(max_len, length)\n    \n    print(max_len)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc320_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    A = int(data[0])\n    B = int(data[1])\n    \n    result = (pow(A, B) + pow(B, A)) % 1000000007\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc321_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    scores = []\n    idx = 2\n    for i in range(n-1):\n        scores.append(int(data[idx]))\n        idx += 1\n        \n    # Sort the scores\n    scores.sort()\n    \n    total_sum = sum(scores)\n    min_score_needed = float('inf')\n    \n    # Try all possible scores in round N\n    for candidate in range(0, 101):\n        remaining_sum = total_sum - candidate\n        remaining_count = n - 2\n        \n        # Calculate average needed for remaining count\n        avg_needed = remaining_sum / remaining_count\n        \n        # Check if this candidate is feasible\n        if avg_needed < scores[0] + scores[-1]:\n            continue\n            \n        # Find the maximum score we can use without exceeding avg_needed\n        max_possible = min(candidate, avg_needed * remaining_count)\n        \n        # Check if we can get at least x with this candidate\n        current_sum = 0\n        for i in range(remaining_count):\n            current_sum += scores[i]\n            if current_sum >= x:\n                break\n                \n        if current_sum >= x:\n            min_score_needed = min(min_score_needed, candidate)\n            \n    if min_score_needed == float('inf'):\n        print(-1)\n    else:\n        print(int(min_score_needed))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc321_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        n_str = data[index].strip()\n        index += 1\n        \n        # Convert string to list of digits\n        digits = [int(d) for d in n_str]\n        \n        # Check if digits are strictly decreasing\n        valid = True\n        for i in range(len(digits)):\n            if i + 1 < len(digits) and digits[i] >= digits[i + 1]:\n                valid = False\n                break\n                \n        print(\"Yes\" if valid else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc322_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = data[1]\n    \n    for i in range(N - 2):\n        if S[i:i+3] == \"ABC\":\n            print(i + 1)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc322_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    S = data[2]\n    T = data[3]\n    \n    if S == T[:N]:\n        print(1)\n    elif S == T[-N:]:\n        print(2)\n    else:\n        print(3)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc323_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    results = []\n    for i in range(1, N + 1):\n        results.append(''.join(data[i:i+N]))\n    \n    # Count wins for each player\n    wins = [0] * (N + 1)\n    for i in range(N):\n        for j in range(i + 1, N):\n            if results[i][j] == 'o':\n                wins[i + 1] += 1\n            elif results[i][j] == 'x':\n                wins[j + 1] += 1\n    \n    # Sort by wins descending, then by player number ascending\n    sorted_indices = sorted(range(1, N + 1), key=lambda idx: (-wins[idx], idx))\n    print(' '.join(map(str, sorted_indices)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc323_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if len(data) != 16 or any(c not in '01' for c in data):\n        print(\"No\")\n        return\n        \n    valid = True\n    for i in range(2, 17, 2):\n        if data[i] == '1':\n            valid = False\n            break\n            \n    print(\"Yes\" if valid else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc324_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    first_val = arr[0]\n    for val in arr:\n        if val != first_val:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc324_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        n_str = data[index].strip()\n        index += 1\n        \n        # Check divisibility by 2\n        if (int(n_str) % 2 != 0):\n            print(\"No\")\n            continue\n            \n        # Check divisibility by 3\n        total = 0\n        for char in n_str:\n            digit = int(char)\n            total += digit * (3 ** len(n_str))\n            \n        if (total % 3 != 0):\n            print(\"No\")\n            continue\n            \n        # If both conditions are satisfied, it's possible\n        print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc325_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    S = data[0]\n    T = data[1]\n    \n    print(f\"{S} {T} san\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc326_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    \n    # Find the smallest multiple of 10 that is >= N\n    k = (N + 9) // 10 * 10\n    \n    # Check if k is 326-like\n    if k < 100 or k > 919:\n        print(\"No such number\")\n        return\n        \n    if k % 10 == k // 10:\n        print(k)\n        return\n        \n    # If not, we need to increment k until it becomes 326-like\n    while True:\n        # Increment k by 10 to get the next multiple of 10\n        k += 10\n        if k > 919:\n            break\n            \n        # Check if the new k is 326-like\n        if k < 100 or k > 919:\n            continue\n            \n        if k % 10 == k // 10:\n            print(k)\n            return\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc326_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Check if we can reach Y using only stairs\n    if abs(X - Y) <= 2:\n        print(\"Yes\")\n        return\n    \n    # Check if we can reach Y using only elevators\n    if abs(X - Y) > 20:\n        print(\"No\")\n        return\n    \n    # If neither condition holds, check if we need to go through elevators\n    # We'll simulate the process\n    current_floor = X\n    moves = []\n    \n    while True:\n        # Try to move directly (using stairs)\n        if abs(current_floor - Y) <= 2:\n            moves.append(f\"U {abs(current_floor - Y)}\")\n            break\n        \n        # Try to move via elevator\n        if abs(current_floor - Y) > 20:\n            moves.append(\"E\")\n        \n        # Move one floor at a time\n        if current_floor < Y:\n            moves.append(\"U 1\")\n            current_floor += 1\n        else:\n            moves.append(\"D 1\")\n            current_floor -= 1\n    \n    # Print all moves\n    print(\"\\n\".join(moves))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc327_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    S = data[1]\n    \n    for i in range(N - 1):\n        if S[i] == 'a' and S[i + 1] == 'b':\n            print(\"Yes\")\n            return\n        elif S[i] == 'b' and S[i + 1] == 'a':\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc327_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    B = int(data[0])\n    \n    # Check for small cases first\n    if B == 1:\n        print(1)\n        return\n        \n    if B < 4:\n        print(-1)\n        return\n        \n    # For large B, use logarithmic approach\n    # We'll check powers up to sqrt(B) and down to 1\n    import math\n    \n    # Check downwards from B down to 1\n    for i in range(1, int(math.isqrt(B)) + 1):\n        if i * i > B:\n            break\n        if (i ** i) == B:\n            print(i)\n            return\n            \n    # If we didn't find anything below, check upwards from 1 up to sqrt(B)\n    for i in range(1, int(math.isqrt(B)) + 1):\n        power = i ** i\n        if power <= B:\n            print(i)\n        else:\n            break\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc328_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    D = list(map(int, data[1:1+N]))\n    \n    count = 0\n    \n    # Iterate through each month\n    for i in range(1, N + 1):\n        # Iterate through each day in the current month\n        for j in range(1, D[i-1] + 1):\n            # Convert month number to string\n            month_str = str(i)\n            \n            # Check if both month and day have the same digit set\n            if len(month_str) == 1:\n                # Month is single digit, check if it matches day\n                if month_str == str(j):\n                    count += 1\n            else:\n                # Month is multi-digit, convert to list of digits\n                month_digits = [int(d) for d in month_str]\n                \n                # Check if all digits match those in day\n                if sorted(month_digits) == sorted([int(d) for d in str(j)]):\n                    count += 1\n                    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc328_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    X = int(data[1])\n    \n    scores = list(map(int, data[2:2+N]))\n    \n    total_score = 0\n    for score in scores:\n        if score <= X:\n            total_score += score\n            \n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc329_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    for char in data:\n        print(char, end=\" \")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc329_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    max_val = max(arr)\n    result = None\n    \n    for num in arr:\n        if num != max_val and (result is None or num > result):\n            result = num\n            \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc330_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    L = int(data[1])\n    R = int(data[2])\n    \n    A = list(map(int, data[3:3+N]))\n    \n    # Precompute prefix sums\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i-1] + A[i-1]\n    \n    # Precompute suffix sums  \n    suffix_sum = [0] * (N + 1)\n    for i in range(N-1, -1, -1):\n        suffix_sum[i] = suffix_sum[i+1] + A[i]\n    \n    # Precompute prefix max and suffix min\n    prefix_max = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_max[i] = max(prefix_max[i-1], A[i-1])\n    \n    suffix_min = [0] * (N + 1)\n    for i in range(N-1, -1, -1):\n        suffix_min[i] = min(suffix_min[i+1], A[i])\n    \n    # Precompute prefix min and suffix max\n    prefix_min = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_min[i] = min(prefix_min[i-1], A[i-1])\n    \n    suffix_max = [0] * (N + 1)\n    for i in range(N-1, -1, -1):\n        suffix_max[i] = max(suffix_max[i+1], A[i])\n    \n    # Precompute prefix sum differences\n    prefix_diff = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_diff[i] = prefix_sum[i] - prefix_sum[i-1]\n    \n    # Precompute suffix sum differences\n    suffix_diff = [0] * (N + 1)\n    for i in range(N-1, -1, -1):\n        suffix_diff[i] = suffix_sum[i] - suffix_sum[i+1]\n    \n    # Precompute prefix min differences\n    prefix_min_diff = [0] * (N + 1)\n    for i in range(1,"
  },
  {
    "id": "abc330_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    L = int(data[1])\n    \n    scores = list(map(int, data[2:2+N]))\n    \n    count = 0\n    for score in scores:\n        if score >= L:\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc331_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    M, D = map(int, data[0].split())\n    y, m, d = map(int, data[1:])\n\n    # Calculate total number of days in the current year\n    total_days_in_year = (m - 1) * D + d\n    \n    # Add 1 day to get the next day\n    next_day = total_days_in_year + 1\n    \n    # If we exceed the number of days in a year, wrap around to new year\n    if next_day > M * D:\n        next_y = y + 1\n        next_m = 1\n        next_d = 1\n    else:\n        # Find the corresponding month and day in the next year\n        month_index = (m - 1) % M\n        day_index = (d - 1) % D\n        \n        # Adjust for negative indices\n        if month_index < 0:\n            month_index += M\n        if day_index < 0:\n            day_index += D\n            \n        next_m = month_index + 1\n        next_d = day_index + 1\n        \n        # Ensure it's within valid range\n        if next_d > D:\n            next_m += 1\n            next_d -= D\n            if next_m > M:\n                next_y += 1\n                next_m = 1\n                \n    print(f\"{next_y} {next_m} {next_d}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc331_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = int(data[1])\n    M = int(data[2])\n    L = int(data[3])\n    \n    # Precompute cost for different combinations\n    cost = {}\n    cost[(6, 8)] = S\n    cost[(6, 12)] = L\n    cost[(8, 12)] = M\n    \n    # DP table: dp[i][j] = min cost to get i eggs with j packs\n    dp = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n    \n    for i in range(0, N + 1):\n        for j in range(0, N + 1):\n            if dp[i][j] == float('inf'):\n                continue\n                \n            # Try adding 6-egg packs\n            if i >= 6:\n                new_i = i - 6\n                new_j = j + 1\n                dp[new_i][new_j] = min(dp[new_i][new_j], dp[i][j] + cost[(6, 8)])\n            \n            # Try adding 8-egg packs  \n            if i >= 8:\n                new_i = i - 8\n                new_j = j + 1\n                dp[new_i][new_j] = min(dp[new_i][new_j], dp[i][j] + cost[(8, 12)])\n                \n            # Try adding 12-egg packs\n            if i >= 12:\n                new_i = i - 12\n                new_j = j + 1\n                dp[new_i][new_j] = min(dp[new_i][new_j], dp[i][j] + cost[(12, 6)])\n    \n    result = min(dp[N])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc332_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    s = int(data[1])\n    k = int(data[2])\n    \n    prices = []\n    quantities = []\n    \n    idx = 3\n    for i in range(n):\n        p = int(data[idx])\n        q = int(data[idx + 1])\n        prices.append(p)\n        quantities.append(q)\n        idx += 2\n    \n    total_price = sum(p * q for p, q in zip(prices, quantities))\n    \n    if total_price >= s:\n        shipping_fee = 0\n    else:\n        shipping_fee = k\n        \n    result = total_price + shipping_fee\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc332_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    K = int(data[0])\n    G = int(data[1])\n    M = int(data[2])\n    \n    # Initialize state: (glass_water, mug_water)\n    state = (0, 0)\n    \n    for _ in range(K):\n        glass_water, mug_water = state\n        \n        # Check if we need to refill the mug\n        if mug_water == 0:\n            mug_water = G\n        \n        # Transfer water from mug to glass until either glass is full or mug is empty\n        while glass_water < G and mug_water > 0:\n            glass_water += 1\n            mug_water -= 1\n    \n    print(f\"{state[0]} {state[1]}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc333_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    S1, S2 = data[0], data[1]\n    T1, T2 = data[2], data[3]\n    \n    # Define pentagon vertices\n    vertices = {\n        'A': (0, 0),\n        'B': (1, 0),\n        'C': (1/2, math.sqrt(3)/2),\n        'D': (-1/2, math.sqrt(3)/2),\n        'E': (-1, 0)\n    }\n    \n    def distance(p1, p2):\n        return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)\n    \n    def get_segment_length(point1, point2):\n        x1, y1 = point1\n        x2, y2 = point2\n        dx = x2 - x1\n        dy = y2 - y1\n        return math.sqrt(dx*dx + dy*dy)\n    \n    def get_distance_between_points(a, b):\n        ax, ay = a\n        bx, by = b\n        return math.sqrt((ax-bx)**2 + (ay-by)**2)\n    \n    def get_distance_from_point_to_line(point, line):\n        x, y = point\n        A, B, C = line\n        numerator = abs(A*x + B*y + C)\n        denominator = math.sqrt(A*A + B*B)\n        return numerator / denominator\n    \n    def get_distance_from_vertex_to_edge(vertex, edge):\n        x, y = vertex\n        A, B, C = edge\n        numerator = abs(A*x + B*y + C)\n        denominator = math.sqrt(A*A + B*B)\n        return numerator / denominator\n    \n    def get_distance_from_vertex_to_edge_at_vertex(vertex, edge):\n        x, y = vertex\n        A, B, C = edge\n        numerator = abs(A*x + B*y + C)\n        denominator = math.sqrt(A*A + B*B)\n        if numerator == 0:\n            return 0\n        t = numerator / denominator\n        if t < 0 or t > 1:\n            return 0\n        px = x + t * (edge[0] - x)\n        py = y + t * (edge[1] - y)\n        return distance((px, py), vertex)\n    \n    def get"
  },
  {
    "id": "abc333_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    N = int(data)\n    \n    result = str(N) * N\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc334_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    B = int(data[0])\n    G = int(data[1])\n    \n    if B > G:\n        print(\"Bat\")\n    else:\n        print(\"Glove\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc335_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    # Extract the last four characters (excluding the trailing 3)\n    last_four = data[-4:]\n    \n    # Change the last character to '4'\n    new_last_char = chr(ord(last_four[-1]) + 1)\n    \n    # Construct the new string\n    result = data[:-4] + new_last_char\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc335_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    \n    # Generate triples using nested loops\n    for x in range(N + 1):\n        for y in range(N - x + 1):\n            z = N - x - y\n            print(f\"{x} {y} {z}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc336_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    N = int(data[0])\n    \n    # Precompute the Dragon Strings for levels up to 2024\n    dragon_strings = [\"\"] * (N + 1)\n    dragon_strings[0] = \"Long\"\n    \n    for i in range(1, N + 1):\n        # Start with \"L\" at position 0\n        dragon_strings[i] = \"L\"\n        \n        # Insert \"o\" at positions 1 to i-1\n        for j in range(1, i):\n            dragon_strings[i] += \"o\" * (j - 1)\n        \n        # Insert \"n\" at position i\n        dragon_strings[i] += \"n\"\n        \n        # Insert \"g\" at position i+1\n        dragon_strings[i] += \"g\"\n    \n    print(dragon_strings[N])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc336_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    try:\n        N = int(data)\n        result = ctz(N)\n        print(result)\n    except ValueError:\n        print(0)\n\ndef ctz(X):\n    if X == 0:\n        return 0\n    \n    # Count the number of trailing zeros by repeatedly dividing by 2\n    count = 0\n    while X % 2 == 0:\n        X //= 2\n        count += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc337_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    n = len(data)\n    \n    # Check if all characters are 'A'\n    if all(ch == 'A' for ch in data):\n        print(\"Yes\")\n        return\n    \n    # Check if all characters are 'B'\n    if all(ch == 'B' for ch in data):\n        print(\"Yes\")\n        return\n    \n    # Check if all characters are 'C'\n    if all(ch == 'C' for ch in data):\n        print(\"Yes\")\n        return\n    \n    # Try to find three substrings: first part, second part, last part\n    for i in range(1, n - 1):\n        for j in range(i + 1, n - 1):\n            first_part = data[:i]\n            second_part = data[i:j+1]\n            third_part = data[j+1:]\n            \n            # Check if each part is an extended string\n            if (all(c == 'A' for c in first_part) and \n                all(c == 'B' for c in second_part) and \n                all(c == 'C' for c in third_part)):\n                    print(\"Yes\")\n                    return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc337_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    takahashi_score = 0\n    aoki_score = 0\n    \n    for i in range(n):\n        x_i = int(data[1 + 2 * i])\n        y_i = int(data[2 + 2 * i])\n        \n        if x_i > y_i:\n            takahashi_score += x_i\n        elif y_i > x_i:\n            aoki_score += y_i\n        else:\n            continue\n    \n    if takahashi_score > aoki_score:\n        print(\"Takahashi\")\n    elif aoki_score > takahashi_score:\n        print(\"Aoki\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc338_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if len(data) == 0:\n        return\n    \n    s = data.strip()\n    \n    # Check if first character is uppercase\n    if not s[0].isupper():\n        print(\"No\")\n        return\n        \n    # Check if all other characters are lowercase\n    for i in range(1, len(s)):\n        if not s[i].islower():\n            print(\"No\")\n            return\n            \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc338_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    freq = {}\n    for char in data:\n        freq[char] = freq.get(char, 0) + 1\n    \n    max_count = max(freq.values()) if freq else 0\n    result_char = min([char for char, count in freq.items() if count == max_count])\n    \n    print(result_char)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc339_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    s = data[0].strip()\n    \n    # Find the first occurrence of '..'\n    dot_pos = -1\n    for i in range(len(s) - 1):\n        if s[i] == '.' and s[i+1] == '.':\n            dot_pos = i\n            break\n    \n    if dot_pos == -1:\n        print(s)\n    else:\n        # Split at the first '..' and take the second part\n        prefix = s[:dot_pos]\n        suffix = s[dot_pos+2:]\n        result = prefix + suffix\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc340_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index]); index += 1\n        queries = []\n        for i in range(n):\n            query_type = int(data[index]); index += 1\n            if query_type == 1:\n                x = int(data[index]); index += 1\n                queries.append((query_type, x))\n            else:\n                k = int(data[index]); index += 1\n                queries.append((query_type, k))\n        \n        # Precompute answers for all queries of type 2 (k-th from end)\n        answers = []\n        temp = []\n        for query in queries:\n            if query[0] == 1:\n                x = query[1]\n                temp.append(x)\n            else:\n                k = query[1]\n                while len(temp) > k - 1:\n                    temp.pop()\n                answers.append(temp[-1])\n        \n        # Process queries of type 1\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                x = query[1]\n                temp.append(x)\n            else:\n                k = query[1]\n                while len(temp) > k - 1:\n                    temp.pop()\n                result.append(str(answers.pop()))\n        \n        print(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc340_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    A = int(data[0])\n    B = int(data[1])\n    D = int(data[2])\n    \n    # Calculate number of terms\n    n = ((B - A) // D) + 1\n    \n    # Generate the arithmetic sequence\n    result = []\n    current = A\n    for i in range(n):\n        result.append(str(current))\n        current += D\n    \n    print(\" \".join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc341_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Precompute prefix sums for A_i\n    prefix_A = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_A[i] = prefix_A[i - 1] + int(data[i])\n    \n    # Precompute suffix sums for S_i\n    suffix_S = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_S[i] = suffix_S[i + 1] + int(data[n + i + 1])\n    \n    # Precompute suffix sums for T_i\n    suffix_T = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_T[i] = suffix_T[i + 1] + int(data[n + i + 1])\n    \n    max_units = 0\n    \n    # Try all possible starting country\n    for start in range(1, n):\n        total_gain = 0\n        \n        # Calculate initial gain from first operation\n        if prefix_A[start] >= suffix_S[start]:\n            total_gain += suffix_T[start]\n        \n        # Calculate remaining gains from subsequent operations\n        for i in range(start + 1, n):\n            if prefix_A[i] >= suffix_S[i]:\n                total_gain += suffix_T[i]\n        \n        # Update maximum units\n        current_max = prefix_A[n] + total_gain\n        if current_max > max_units:\n            max_units = current_max\n    \n    print(max_units)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc341_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    N = int(data[0])\n    \n    result = []\n    for i in range(N):\n        if i % 2 == 0:\n            result.append('0')\n        else:\n            result.append('1')\n            \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc342_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    s = data[0].strip()\n    \n    # Find the position of the differing character\n    diff_pos = s.index(s[1])\n    \n    # Calculate x: (length - 1) * count + pos\n    n = len(s)\n    count = n // 2\n    x = (n - 1) * count + diff_pos\n    \n    print(x)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc342_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    p_list = list(map(int, data[1:1+n]))\n    \n    q = int(data[1+n])\n    queries = []\n    idx = 1 + n + 1\n    for i in range(q):\n        a = int(data[idx]); b = int(data[idx+1])\n        queries.append((a, b))\n        idx += 2\n        \n    # Precompute prefix sums for each person's position\n    prefix = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix[i] = prefix[i-1] + p_list[i-1]\n        \n    results = []\n    for a, b in queries:\n        count_a = prefix[a - 1]\n        count_b = prefix[b]\n        result = count_b - count_a\n        results.append(str(result))\n        \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc343_a",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    A = int(data[0])\n    B = int(data[1])\n    \n    result = [i for i in range(10) if i != (A + B)]\n    print(result[0])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc343_b",
    "model": "diverse_instruction_checkpoint-500",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    A = []\n    index = 1\n    for i in range(N):\n        row = list(map(int, data[index:index+N]))\n        index += N\n        A.append(row)\n    \n    result = []\n    for i in range(1, N+1):\n        neighbors = [j for j in range(1, N+1) if A[i-1][j-1] == 1]\n        neighbors.sort()\n        result.append(' '.join(map(str, neighbors)))\n    \n    print('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  }
]