[
  {
    "id": "abc301_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    s = data[1]\n    \n    takahashi_wins = 0\n    aoki_wins = 0\n    \n    for i, char in enumerate(s):\n        if char == 'T':\n            takahashi_wins += 1\n        else:  # char == 'A'\n            aoki_wins += 1\n            \n        if takahashi_wins > aoki_wins:\n            break\n        elif aoki_wins > takahashi_wins:\n            continue\n        else:\n            if i + 1 < n:\n                if s[i+1] == 'T':\n                    takahashi_wins += 1\n                else:\n                    aoki_wins += 1\n            else:\n                break\n                \n    if takahashi_wins > aoki_wins:\n        print('T')\n    else:\n        print('A')\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc301_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    A = list(map(int, data[1:1+N]))\n    \n    while True:\n        found = False\n        for i in range(N-1):\n            if abs(A[i] - A[i+1]) != 1:\n                # Insert elements between A[i] and A[i+1]\n                start_val = min(A[i], A[i+1]) - 1\n                end_val = max(A[i], A[i+1]) + 1\n                \n                # Generate all possible sequences between start_val and end_val\n                for j in range(start_val, end_val + 1):\n                    new_seq = A[:i] + [j] + A[i+1:]\n                    if len(new_seq) == N:\n                        A = new_seq\n                        found = True\n                        break\n                if found:\n                    break\n        if not found:\n            break\n            \n    print(' '.join(map(str, A)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc302_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    \n    if B >= A:\n        print(0)\n        return\n        \n    count = 0\n    while A > 0:\n        A -= B\n        count += 1\n        \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc303_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    grid = []\n    idx = 2\n    for i in range(M):\n        row = list(map(int, data[idx:idx+N]))\n        idx += N\n        grid.append(row)\n    \n    # Build adjacency matrix\n    adj = [[False] * N for _ in range(N)]\n    for i in range(M):\n        for j in range(i+1, M):\n            if grid[i][j] != 0 or grid[j][i] != 0:\n                adj[grid[i][j]-1][grid[j][i]-1] = True\n    \n    # Count bad mood pairs using DFS\n    def dfs(node, visited):\n        count = 0\n        for neighbor in range(N):\n            if not visited[neighbor] and adj[node][neighbor]:\n                visited[neighbor] = True\n                count += dfs(neighbor, visited) + 1\n        return count\n    \n    total_bad = 0\n    for node in range(N):\n        visited = [False] * N\n        visited[node] = True\n        total_bad += dfs(node, visited)\n    \n    print(total_bad)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc303_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    s = data[1]\n    t = data[2]\n    \n    def is_similar_char(c1, c2):\n        return c1 == c2 or (c1 == '1' and c2 == 'l') or (c1 == '0' and c2 == 'o')\n    \n    for i in range(n):\n        if not is_similar_char(s[i], t[i]):\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc304_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    people = []\n    \n    for i in range(1, N + 1):\n        name = data[i]\n        age = int(data[i + N])\n        people.append((name, age))\n    \n    # Sort by age (if ages equal, sort lexicographically)\n    sorted_people = sorted(people, key=lambda x: (x[1], x[0]))\n    \n    for name, _ in sorted_people:\n        print(name)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc304_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    N = int(data)\n    \n    if N <= 10**3 - 1:\n        print(N)\n    elif N <= 10**4 - 1:\n        print(str(N)[0:-1])\n    elif N <= 10**5 - 1:\n        print(str(N)[0:-2])\n    elif N <= 10**6 - 1:\n        print(str(N)[0:-3])\n    elif N <= 10**7 - 1:\n        print(str(N)[0:-4])\n    elif N <= 10**8 - 1:\n        print(str(N)[0:-5])\n    else:  # N <= 10**9 - 1\n        print(str(N)[0:-6])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc305_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    \n    # Calculate positions of water stations\n    water_positions = []\n    current_pos = 0\n    while current_pos <= N:\n        water_positions.append(current_pos)\n        current_pos += 5\n    \n    # Find the closest water station to N\n    min_distance = float('inf')\n    best_station = None\n    \n    for pos in water_positions:\n        dist = abs(N - pos)\n        if dist < min_distance:\n            min_distance = dist\n            best_station = pos\n    \n    print(best_station)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc305_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    p = data[0]\n    q = data[1]\n    \n    if p == 'A':\n        if q == 'B':\n            print(3)\n        elif q == 'C':\n            print(4)\n        elif q == 'D':\n            print(5)\n        elif q == 'E':\n            print(6)\n        elif q == 'F':\n            print(7)\n        else:  # q == 'G'\n            print(8)\n            \n    elif p == 'B':\n        if q == 'C':\n            print(1)\n        elif q == 'D':\n            print(4)\n        elif q == 'E':\n            print(5)\n        elif q == 'F':\n            print(6)\n        else:  # q == 'G'\n            print(7)\n            \n    elif p == 'C':\n        if q == 'D':\n            print(4)\n        elif q == 'E':\n            print(5)\n        elif q == 'F':\n            print(6)\n        else:  # q == 'G'\n            print(7)\n            \n    elif p == 'D':\n        if q == 'E':\n            print(5)\n        elif q == 'F':\n            print(6)\n        else:  # q == 'G'\n            print(7)\n            \n    elif p == 'E':\n        if q == 'F':\n            print(6)\n        else:  # q == 'G'\n            print(7)\n            \n    elif p == 'F':\n        if q == 'G':\n            print(9)\n        else:  # q == 'A'\n            print(10)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc306_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = data[1]\n    \n    result = []\n    for char in S:\n        result.append(char)\n        result.append(char)\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc306_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = list(map(int, data))\n    \n    result = 0\n    for i in range(64):\n        if A[i] == 1:\n            result += (1 << i)\n            \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc307_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    A = list(map(int, data[1:1+N*7]))\n    \n    total_steps_per_week = []\n    current_sum = 0\n    for i in range(7):\n        current_sum += A[i]\n        if i < N:\n            total_steps_per_week.append(current_sum)\n    \n    print(' '.join(map(str, total_steps_per_week)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc307_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    strings = []\n    for i in range(1, n + 1):\n        strings.append(data[i])\n    \n    # Check all pairs (i, j) with i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            s1 = strings[i]\n            s2 = strings[j]\n            \n            # Concatenate in both orders\n            concat1 = s1 + s2\n            concat2 = s2 + s1\n            \n            # Check if either is a palindrome\n            if concat1 == concat1[::-1] or concat2 == concat2[::-1]:\n                print(\"Yes\")\n                return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc308_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    S = list(map(int, data))\n    \n    # Check monotonicity\n    if not all(S[i] <= S[i+1] for i in range(7)):\n        print(\"No\")\n        return\n        \n    # Check bounds\n    if any(s < 100 or s > 675 for s in S):\n        print(\"No\")\n        return\n        \n    # Check divisibility by 25\n    if any(s % 25 != 0 for s in S):\n        print(\"No\")\n        return\n        \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc308_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    colors = []\n    for i in range(N):\n        colors.append(data[2 + 2*i])\n    \n    dishes = []\n    for i in range(M):\n        dishes.append(data[2 + 2*N + 2*i])\n    \n    prices = list(map(int, data[2 + 2*N + 2*M]))\n    \n    total_price = 0\n    for i in range(N):\n        color = colors[i]\n        dish_index = -1\n        for j in range(M):\n            if dishes[j] == color:\n                dish_index = j\n                break\n        \n        if dish_index != -1:\n            total_price += prices[dish_index]\n        else:\n            total_price += prices[0]\n    \n    print(total_price)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc309_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    \n    # Create the 3x3 grid\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    \n    # Find the positions of A and B\n    pos_A = None\n    pos_B = None\n    \n    for i in range(3):\n        for j in range(3):\n            if grid[i][j] == A:\n                pos_A = (i, j)\n            elif grid[i][j] == B:\n                pos_B = (i, j)\n    \n    # Check horizontal adjacency\n    if pos_A[0] == pos_B[0]:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc309_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    grid = []\n    for i in range(N):\n        row = list(map(int, data[1 + i * N:1 + (i + 1) * N]))\n        grid.append(row)\n    \n    # Create new grid to store shifted values\n    shifted_grid = [[0] * N for _ in range(N)]\n    \n    # Shift top row\n    for j in range(N):\n        shifted_grid[0][j] = grid[1][j]\n    \n    # Shift right column  \n    for i in range(1, N):\n        shifted_grid[i][N-1] = grid[i][N-2]\n    \n    # Shift bottom row  \n    for j in range(N-1, -1, -1):\n        shifted_grid[N-1][j] = grid[N-2][j]\n    \n    # Shift left column  \n    for i in range(N-1, 0, -1):\n        shifted_grid[i][0] = grid[i-1][0]\n    \n    # Copy back to original grid\n    for i in range(N):\n        for j in range(N):\n            grid[i][j] = shifted_grid[i][j]\n    \n    # Output result\n    for i in range(N):\n        print(''.join(str(x) for x in grid[i]))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc310_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    P = int(data[1])\n    Q = int(data[2])\n    \n    D = list(map(int, data[3:3+N]))\n    \n    # Sort dishes by price descending\n    D.sort(reverse=True)\n    \n    min_total = float('inf')\n    \n    # Try using coupon with each dish as the first item\n    for i in range(N):\n        cost = Q + D[i]\n        if cost < min_total:\n            min_total = cost\n            \n    # Try not using coupon (regular price)\n    if min_total > P:\n        print(P)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc310_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    prices = []\n    functions = []\n    for i in range(N):\n        p = int(data[2 + 2*i])\n        c = int(data[2 + 2*i + 1])\n        f = list(map(int, data[2 + 2*i + 2:2 + 2*i + 2+c]))\n        prices.append(p)\n        functions.append(f)\n    \n    # Check each pair (i, j) where i < j\n    for i in range(N):\n        for j in range(i+1, N):\n            pi = prices[i]\n            pj = prices[j]\n            \n            # Check condition 1: pi >= pj\n            if pi < pj:\n                continue\n                \n            # Check condition 2: functions of i must be subset of functions of j\n            # Convert to sets for comparison\n            set_i = set(functions[i])\n            set_j = set(functions[j])\n            if not set_i.issubset(set_j):\n                continue\n                \n            # Check condition 3: pi > pj or j has additional functions\n            if pi <= pj:\n                # Condition 3 satisfied\n                print(\"Yes\")\n                return\n                \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc311_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    S = data[1]\n    \n    count_A = 0\n    count_B = 0\n    count_C = 0\n    \n    for char in S:\n        if char == 'A':\n            count_A += 1\n        elif char == 'B':\n            count_B += 1\n        else:  # char == 'C'\n            count_C += 1\n            \n        if count_A > 0 and count_B > 0 and count_C > 0:\n            print(N)\n            return\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc311_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    d = int(data[1])\n    \n    schedules = []\n    index = 2\n    for i in range(n):\n        schedules.append(data[index:index+d])\n        index += d\n    \n    max_days = 0\n    \n    # Try all starting positions\n    for start_day in range(d):\n        # Check if we can cover all days with this starting position\n        covered = [False] * d\n        for i in range(n):\n            # Check if all characters in S_i from start_day to min(start_day + d - 1, d) are 'o'\n            valid = True\n            for j in range(max(0, start_day), min(start_day + d, d)):\n                if schedules[i][j] != 'o':\n                    valid = False\n                    break\n            if not valid:\n                continue\n                \n            # Mark the covered days\n            for j in range(max(0, start_day), min(start_day + d, d)):\n                covered[j] = True\n        \n        # Count how many days are covered\n        count = sum(covered)\n        if count > max_days:\n            max_days = count\n            \n    print(max_days)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc312_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if len(data) != 3 or not all(c.isupper() for c in data):\n        print(\"No\")\n        return\n        \n    s = data[0]\n    \n    # Check if s is one of the target strings\n    if s == \"ACE\" or s == \"BDF\" or s == \"CEG\" or s == \"DFA\" or \\\n       s == \"EGB\" or s == \"FAC\" or s == \"GBD\":\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc312_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    m = int(data[1])\n    \n    grid = []\n    for i in range(n):\n        grid.append(data[2 + i * m:2 + (i + 1) * m])\n    \n    def is_tak_code(i, j):\n        # Check top-left three-by-three region\n        if grid[i][j] != '#' or grid[i][j+1] != '#' or grid[i][j+2] != '#':\n            return False\n        if grid[i+1][j] != '.' or grid[i+1][j+1] != '.' or grid[i+1][j+2] != '.':\n            return False\n        if grid[i+2][j] != '#' or grid[i+2][j+1] != '#' or grid[i+2][j+2] != '#':\n            return False\n        \n        # Check bottom-right three-by-three region  \n        if grid[i][j] != '#' or grid[i][j+1] != '#' or grid[i][j+2] != '#':\n            return False\n        if grid[i+1][j] != '.' or grid[i+1][j+1] != '.' or grid[i+1][j+2] != '.':\n            return False\n        if grid[i+2][j] != '#' or grid[i+2][j+1] != '#' or grid[i+2][j+2] != '#':\n            return False\n        \n        # Check adjacency between top-left and bottom-right regions\n        if grid[i][j] == '#' and grid[i+1][j] == '.' and grid[i+2][j] == '.':\n            return True\n        if grid[i][j] == '.' and grid[i+1][j] == '#' and grid[i+2][j] == '.':\n            return True\n        if grid[i][j] == '.' and grid[i+1][j] == '.' and grid[i+2][j] == '#':\n            return True\n        if grid[i][j] == '#' and grid[i+1][j] == '.' and grid[i+2][j] == '#':\n            return True\n        if grid[i][j] == '.' and grid[i+1][j] == '#' and grid[i+2][j] == '.':\n            return True\n        if grid[i][j"
  },
  {
    "id": "abc313_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    scores = list(map(int, data[1:1+n]))\n    \n    min_score = min(scores)\n    result = max(0, min_score - 1)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc314_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    N = int(data)\n    \n    # Precomputed digits for pi up to 100 decimal places\n    pi_digits = [\n        \"3\", \"1\", \"4\", \"1\", \"5\",\n        \"9\", \"2\", \"6\", \"5\", \"3\",\n        \"5\", \"8\", \"9\", \"7\", \"9\",\n        \"3\", \"2\", \"3\", \"8\", \"4\",\n        \"6\", \"2\", \"6\", \"2\", \"0\",\n        \"8\", \"9\", \"9\", \"8\", \"0\",\n        \"8\", \"6\", \"2\", \"5\", \"3\",\n        \"5\", \"1\", \"0\", \"5\", \"8\",\n        \"2\", \"0\", \"9\", \"7\", \"4\",\n        \"9\", \"0\", \"4\", \"5\", \"9\",\n        \"2\", \"3\", \"0\", \"7\", \"8\"\n    ]\n    \n    # Truncate to N decimal places\n    truncated = ''.join(pi_digits[:N+1])\n    \n    # Remove trailing zeros\n    while len(truncated) > 1 and truncated[-1] == '0':\n        truncated = truncated[:-1]\n    \n    print(truncated)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc314_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    c_list = list(map(int, data[1:1+n]))\n    \n    # Create list of (bet_count, index) tuples\n    bets = []\n    for i in range(n):\n        bets.append((c_list[i], i+1))\n    \n    # Sort by bet count descending, then by index ascending\n    bets.sort(key=lambda x: (-x[0], x[1]))\n    \n    # Collect indices of people with exactly min_bets\n    min_bets = bets[0][0]\n    result_indices = [idx for idx, (count, _) in enumerate(bets) if count == min_bets]\n    \n    # Print results\n    print(len(result_indices))\n    print(' '.join(map(str, result_indices)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc315_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    M = int(data[0])\n    D = list(map(int, data[1:1+M]))\n    \n    total_days = sum(D)\n    middle_day_index = (total_days + 1) // 2\n    \n    current_day = 1\n    month = 1\n    for d in D:\n        if current_day <= middle_day_index <= current_day + d:\n            break\n        current_day += d\n        month += 1\n    \n    print(f\"{month} {current_day - (middle_day_index - current_day)}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc315_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    result = ''.join(c for c in data if c not in 'aeiou')\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc318_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    total_area = 0\n    \n    for i in range(n):\n        a = int(data[2*i + 1])\n        b = int(data[2*i + 2])\n        c = int(data[2*i + 3])\n        d = int(data[2*i + 4])\n        \n        # Calculate area of rectangle: (b-a)*(d-c)\n        area = (b - a) * (d - c)\n        total_area += area\n        \n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc318_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    M = int(data[1])\n    P = int(data[2])\n    \n    if M > P:\n        print(0)\n        return\n        \n    count = (N - M) // P + 1\n    result = count * M\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc319_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    \n    # Precompute all divisors of N\n    divisors = []\n    for d in range(1, 10):\n        if N % d == 0:\n            divisors.append(d)\n    \n    result = []\n    for i in range(N + 1):\n        found = False\n        for d in divisors:\n            if i % (N // d) == 0:\n                result.append(str(d))\n                found = True\n                break\n        if not found:\n            result.append('-')\n    \n    print(''.join(result))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "id": "abc320_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    n = len(data)\n    \n    # Precompute prefix sums for each character\n    prefix_sum = [[0] * (n + 1) for _ in range(26)]\n    for i in range(n):\n        for c in range(26):\n            if data[i] == chr(ord('A') + c):\n                prefix_sum[c][i + 1] = prefix_sum[c][i] + 1\n            else:\n                prefix_sum[c][i + 1] = prefix_sum[c][i]\n    \n    max_len = 0\n    \n    # Check all possible lengths\n    for length in range(1, n + 1):\n        for start in range(n - length + 1):\n            end = start + length - 1\n            count_A = prefix_sum[0][end + 1] - prefix_sum[0][start]\n            count_B = prefix_sum[1][end + 1] - prefix_sum[1][start]\n            count_C = prefix_sum[2][end + 1] - prefix_sum[2][start]\n            count_D = prefix_sum[3][end + 1] - prefix_sum[3][start]\n            count_E = prefix_sum[4][end + 1] - prefix_sum[4][start]\n            count_F = prefix_sum[5][end + 1] - prefix_sum[5][start]\n            count_G = prefix_sum[6][end + 1] - prefix_sum[6][start]\n            \n            total = count_A + count_B + count_C + count_D + count_E + count_F + count_G\n            if total > max_len:\n                max_len = total\n                \n    print(max_len)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc320_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    \n    result = (A ** B) + (B ** A)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc321_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    X = int(data[1])\n    \n    A = list(map(int, data[2:2+N-1]))\n    \n    # Sort the scores\n    A.sort()\n    \n    # Calculate the total possible points without rounding\n    total_points = sum(A)\n    \n    # Calculate the target points needed for final grade >= X\n    target_points = X * (N - 2)\n    \n    # If we already have enough points, we need to round down\n    if target_points <= total_points:\n        # We need to find the minimum score in round N to get at least target_points\n        # The minimum score in round N would be A[N-2] + 1\n        min_score_needed = A[N-2] + 1\n        if min_score_needed > 100:\n            print(-1)\n        else:\n            print(min_score_needed)\n    else:\n        # We need to round up\n        # The ceiling of target_points / (N-2) gives us the minimum score needed\n        import math\n        ceil_value = math.ceil(target_points / (N - 2))\n        if ceil_value > 100:\n            print(-1)\n        else:\n            print(ceil_value)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc321_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    n = int(data)\n    \n    # Convert number to string to access individual digits\n    num_str = str(n)\n    \n    # Check each digit against its successor\n    for i in range(len(num_str)):\n        current_digit = int(num_str[i])\n        next_digit = int(num_str[i + 1]) if i < len(num_str) - 1 else None\n        \n        if next_digit is not None and current_digit >= next_digit:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc322_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = data[1]\n    \n    for i in range(N - 2):\n        if S[i:i+3] == 'ABC':\n            print(i + 1)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc322_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    S = data[2]\n    T = data[3]\n    \n    if len(S) != N or len(T) != M:\n        return\n    \n    # Check if S is a prefix of T\n    if T[:N] == S:\n        print(1)\n        return\n    \n    # Check if S is a suffix of T  \n    if T[-N:] == S:\n        print(2)\n        return\n    \n    # If none of the above conditions hold, S is neither a prefix nor a suffix\n    print(3)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc323_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    results = []\n    \n    for i in range(1, n + 1):\n        s = ''.join(data[i:i+n])\n        \n        # Count wins for player i\n        wins = 0\n        for j in range(n):\n            if s[j] == 'o':\n                wins += 1\n            elif s[j] == 'x':\n                wins -= 1\n        \n        results.append(str(wins))\n    \n    print(' '.join(reversed(results)))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "id": "abc323_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    n = len(data)\n    \n    # Check if all characters at even positions are '0'\n    for i in range(1, n, 2):\n        if data[i] != '0':\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc324_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    first_val = arr[0]\n    for val in arr:\n        if val != first_val:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc324_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    n = int(data)\n    \n    # Check divisibility by 2\n    while n % 2 == 0:\n        n //= 2\n        \n    # Check divisibility by 3\n    while n % 3 == 0:\n        n //= 3\n        \n    # If n becomes 1, then it's divisible by both 2 and 3\n    if n == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc325_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    S = data[0]\n    T = data[1]\n    \n    print(f\"{S} {T} san\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc326_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    N = int(data)\n    \n    # Find the largest 326-like number less than N\n    for d3 in range(9, -1, -1):\n        for d2 in range(9, -1, -1):\n            for d1 in range(9, -1, -1):\n                candidate = 100 * d3 + 10 * d2 + d1\n                if candidate >= N:\n                    # Check if this candidate is 326-like\n                    if d3 * d2 == d1:\n                        print(candidate)\n                        return\n    \n    # If no candidate found (shouldn't happen per problem constraints)\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc326_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Check if we can reach Y using only stairs\n    if abs(Y - X) <= 2:\n        print(\"Yes\")\n        return\n    \n    # Check if we can reach Y using only elevators\n    if abs(Y - X) >= 50:\n        print(\"No\")\n        return\n    \n    # If neither condition holds, we need to check all intermediate floors\n    # We'll simulate both scenarios\n    # Scenario 1: Use stairs for all moves\n    current_floor = X\n    steps_up = 0\n    steps_down = 0\n    \n    while current_floor < Y:\n        if current_floor + 2 <= Y:\n            current_floor += 2\n            steps_up += 1\n        elif current_floor + 3 <= Y:\n            current_floor += 3\n            steps_down += 1\n        else:\n            break\n    \n    if current_floor == Y:\n        print(\"Yes\")\n        return\n    \n    # Scenario 2: Use elevator for all moves\n    current_floor = X\n    elevators_used = 0\n    \n    while current_floor < Y:\n        if current_floor + 2 > Y:\n            elevators_used += 1\n            current_floor -= 3\n        else:\n            current_floor += 2\n    \n    if current_floor == Y:\n        print(\"Yes\")\n        return\n    \n    # Both scenarios failed\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc327_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    S = data[1]\n    \n    for i in range(N - 1):\n        if S[i] == 'a' and S[i + 1] == 'b':\n            print(\"Yes\")\n            return\n        elif S[i] == 'b' and S[i + 1] == 'a':\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc327_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    B = int(data)\n    \n    # Check for small cases\n    if B == 1:\n        print(1)\n        return\n        \n    if B < 4:\n        print(-1)\n        return\n        \n    # Check for perfect squares\n    root = int(B ** 0.5)\n    if root * root == B:\n        print(root)\n        return\n        \n    # Check for powers of 2\n    if (B & (B - 1)) == 0 and B != 0:\n        print(int(B ** (1/3)))\n        return\n        \n    # For larger numbers, use binary search\n    low, high = 1, B\n    \n    while low <= high:\n        mid = (low + high) // 2\n        power = mid ** mid\n        if power == B:\n            print(mid)\n            return\n        elif power < B:\n            low = mid + 1\n        else:\n            high = mid - 1\n            \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc328_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    D = list(map(int, data[1:1+N]))\n    \n    count = 0\n    \n    for i in range(1, N + 1):\n        for j in range(1, D[i] + 1):\n            str_i = str(i)\n            str_j = str(j)\n            \n            # Check if both numbers have same digits\n            if len(str_i) != len(str_j):\n                continue\n                \n            all_same = True\n            for k in range(len(str_i)):\n                if str_i[k] != str_j[k]:\n                    all_same = False\n                    break\n                    \n            if all_same:\n                count += 1\n                \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc328_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    X = int(data[1])\n    \n    scores = list(map(int, data[2:2+N]))\n    \n    total_score = sum(score for score in scores if score <= X)\n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc329_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    for char in data:\n        print(char, end=' ')\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc329_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    max_val = max(arr)\n    result = None\n    \n    for num in arr:\n        if num != max_val and (result is None or num > result):\n            result = num\n            \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc330_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    L = int(data[1])\n    R = int(data[2])\n    \n    A = list(map(int, data[3:3+N]))\n    \n    # Precompute prefix sums\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i-1] + A[i-1]\n    \n    results = []\n    for i in range(N):\n        left = max(L, prefix_sum[i] - R)\n        right = min(R, prefix_sum[i+1] - L)\n        \n        if left > right:\n            results.append(-1)\n        else:\n            results.append((left + right) // 2)\n    \n    print(' '.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc330_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    L = int(data[1])\n    \n    scores = list(map(int, data[2:2+N]))\n    \n    count_passed = sum(1 for score in scores if score >= L)\n    print(count_passed)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc331_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    M = int(data[0])\n    D = int(data[1])\n    \n    y = int(data[2])\n    m = int(data[3])\n    d = int(data[4])\n    \n    # Calculate total number of days since January 1, 2000\n    total_days = (y - 2000) * M * D + (m - 1) * D + (d - 1)\n    \n    # Add 1 day to get the next day\n    next_day = total_days + 1\n    \n    # Convert back to year-month-day\n    year = 2000 + next_day // (M * D)\n    month = 1 + (next_day % (M * D)) // D\n    day = 1 + (next_day % D)\n    \n    print(year, month, day)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc331_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = int(data[1])\n    M = int(data[2])\n    L = int(data[3])\n    \n    # Precompute cost for 6-egg packs\n    cost_6 = [float('inf')] * (N + 1)\n    if N >= 6:\n        cost_6[N] = S\n    \n    # Precompute cost for 8-egg packs  \n    cost_8 = [float('inf')] * (N + 1)\n    if N >= 8:\n        cost_8[N] = M\n    \n    # Precompute cost for 12-egg packs  \n    cost_12 = [float('inf')] * (N + 1)\n    if N >= 12:\n        cost_12[N] = L\n    \n    # Fill arrays using DP\n    for i in range(N, -1, -1):\n        if i >= 6:\n            cost_6[i] = min(cost_6[i], cost_6[i-6] + S)\n        if i >= 8:\n            cost_8[i] = min(cost_8[i], cost_8[i-8] + M)\n        if i >= 12:\n            cost_12[i] = min(cost_12[i], cost_12[i-12] + L)\n    \n    # Find minimum cost for N eggs\n    result = min(cost_6[N], cost_8[N], cost_12[N])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc332_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    s = int(data[1])\n    k = int(data[2])\n    \n    prices = []\n    quantities = []\n    \n    idx = 3\n    for i in range(n):\n        p = int(data[idx]); q = int(data[idx+1])\n        prices.append(p)\n        quantities.append(q)\n        idx += 2\n    \n    total_price = sum(p * q for p, q in zip(prices, quantities))\n    \n    if total_price >= s:\n        shipping_fee = 0\n    else:\n        shipping_fee = k\n        \n    result = total_price + shipping_fee\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc332_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    K = int(data[0])\n    G = int(data[1])\n    M = int(data[2])\n    \n    glass = 0\n    mug = 0\n    \n    for _ in range(K):\n        # If glass is empty, fill it\n        if glass == 0:\n            glass = G\n        \n        # If mug is empty, fill it\n        if mug == 0:\n            mug = M\n            \n        # Transfer water from mug to glass until either glass is full or mug is empty\n        while glass < G and mug > 0:\n            glass += 1\n            mug -= 1\n    \n    print(f\"{glass} {mug}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc333_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    s1, s2 = input().strip()\n    t1, t2 = input().strip()\n    \n    # Convert to coordinates: A=0, B=1, C=2, D=3, E=4\n    coords_s = {\n        'A': (0, 0),\n        'B': (1, 0),\n        'C': (1, 1),\n        'D': (0, 1),\n        'E': (0, 0)\n    }\n    coords_t = {\n        'A': (1, 0),\n        'B': (0, 0),\n        'C': (0, 1),\n        'D': (1, 1),\n        'E': (1, 0)\n    }\n    \n    x1, y1 = coords_s[s1]\n    x2, y2 = coords_s[s2]\n    x3, y3 = coords_s[t1]\n    x4, y4 = coords_s[t2]\n    \n    dist_s = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    dist_t = math.sqrt((x4 - x3)**2 + (y4 - y3)**2)\n    \n    print(\"Yes\" if dist_s == dist_t else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc333_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    n = int(data)\n    \n    # Create the concatenated string by repeating the digit N times\n    result = str(n) * n\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc334_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    B = int(data[0])\n    G = int(data[1])\n    \n    if B > G:\n        print(\"Bat\")\n    else:\n        print(\"Glove\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc335_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data or len(data) < 5 or len(data) > 100:\n        return\n    \n    # Extract the part before the last 2023\n    prefix = data[:-6]\n    \n    # Change the last character to 4\n    modified_char = chr(ord(prefix[-1]) + 1)\n    \n    # Concatenate the modified prefix with the rest of the string\n    result = prefix[:-1] + modified_char\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc335_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    N = int(data)\n    \n    # Generate all triples (x, y, z) where x+y+z <= N\n    # We'll iterate over possible values of x, then y, then z\n    # Since we want lexicographical order, we'll process triples in increasing order\n    \n    # For each x, we can have y from 0 to min(N-x, x)\n    # For each pair (x, y), we can have z from 0 to min(N-x-y, y)\n    \n    # We'll use nested loops to generate these triples\n    for x in range(N + 1):\n        for y in range(x + 1):\n            for z in range(min(N - x - y, y) + 1):\n                print(f\"{x} {y} {z}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc336_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    N = int(data)\n    \n    # Generate Dragon String for level N\n    result = []\n    for i in range(N + 3):\n        if i == 0:\n            result.append('L')\n        elif i == 1:\n            result.append('o')\n        elif i == 2:\n            result.append('o')\n            result.append('o')\n            result.append('o')\n        else:  # i >= 3\n            result.append('n')\n            result.append('g')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc336_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    N = int(data)\n    \n    # Count trailing zeros by repeatedly dividing by 2\n    ctz_count = 0\n    while N % 2 == 0:\n        ctz_count += 1\n        N //= 2\n    \n    print(ctz_count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc337_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    n = len(data)\n    \n    # Check if all characters are 'A'\n    if all(c == 'A' for c in data):\n        print(\"Yes\")\n        return\n    \n    # Check if all characters are 'B'\n    if all(c == 'B' for c in data):\n        print(\"Yes\")\n        return\n    \n    # Check if all characters are 'C'\n    if all(c == 'C' for c in data):\n        print(\"Yes\")\n        return\n    \n    # Check if we can split into three parts: A, B, C\n    i = 0\n    j = 0\n    k = 0\n    \n    while i < n or j < n or k < n:\n        # Find next 'A'\n        while i < n and data[i] != 'A':\n            i += 1\n        \n        # If we reached end without finding 'A', then all remaining must be 'A'\n        if i >= n:\n            # All remaining characters are 'A'\n            if all(data[j+k] == 'A' for k in range(n - i)):\n                print(\"Yes\")\n                return\n            else:\n                break\n        \n        # Found 'A', now find next 'B'\n        j = i + 1\n        while j < n and data[j] != 'B':\n            j += 1\n        \n        # If we reached end without finding 'B', then all remaining must be 'B'\n        if j >= n:\n            # All remaining characters are 'B'\n            if all(data[k+j] == 'B' for k in range(n - j)):\n                print(\"Yes\")\n                return\n            else:\n                break\n        \n        # Found 'B', now find next 'C'\n        k = j + 1\n        while k < n and data[k] != 'C':\n            k += 1\n        \n        # If we reached end without finding 'C', then all remaining must be 'C'\n        if k >= n:\n            # All remaining characters are 'C'\n            if all(data[l+k] == 'C' for l in range(n - k)):\n                print(\"Yes\")\n                return\n            else:\n                break\n        \n        # We found 'A', 'B', 'C' in order, so this is an Extended ABC string\n        print(\"Yes\")\n        return\n    \n    # If we didn't find any pattern, check"
  },
  {
    "id": "abc337_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    takahashi_score = 0\n    aoki_score = 0\n    \n    for i in range(n):\n        x_i = int(data[2*i + 1])\n        y_i = int(data[2*i + 2])\n        takahashi_score += x_i\n        aoki_score += y_i\n        \n    if takahashi_score > aoki_score:\n        print(\"Takahashi\")\n    elif aoki_score > takahashi_score:\n        print(\"Aoki\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc338_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if len(data) == 0:\n        return\n    \n    s = list(data)\n    \n    # Check if first character is uppercase\n    if not s[0].isupper():\n        print(\"No\")\n        return\n        \n    # Check if all other characters are lowercase\n    for i in range(1, len(s)):\n        if not s[i].islower():\n            print(\"No\")\n            return\n            \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc338_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    freq = {}\n    for char in data:\n        freq[char] = freq.get(char, 0) + 1\n    \n    max_count = max(freq.values()) if freq else 0\n    candidates = [char for char, count in freq.items() if count == max_count]\n    \n    # Sort candidates alphabetically and choose first\n    candidates.sort()\n    result = candidates[0]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc339_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data or len(data) < 2:\n        return\n    \n    # Find all occurrences of '..'\n    dot_positions = []\n    for i in range(len(data)):\n        if data[i] == '.' and data[i+1] == '.':\n            dot_positions.append(i)\n    \n    # If no dots, return empty string\n    if not dot_positions:\n        print(\"\")\n        return\n    \n    # Process each pair of consecutive dots\n    for i in range(len(dot_positions) - 1):\n        pos1 = dot_positions[i]\n        pos2 = dot_positions[i+1]\n        \n        # Check if this segment ends with '.'\n        if pos2 + 1 < len(data) and data[pos2+1] == '.':\n            continue\n            \n        # Extract the suffix from pos1 to pos2 (inclusive)\n        suffix = data[pos1:pos2+1]\n        # Reverse it to get the correct order\n        reversed_suffix = suffix[::-1]\n        print(reversed_suffix)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc340_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    A = []\n    index = 1\n    \n    for _ in range(n):\n        query_type = int(data[index]); index += 1\n        \n        if query_type == 1:\n            x = int(data[index]); index += 1\n            A.append(x)\n        \n        elif query_type == 2:\n            k = int(data[index]); index += 1\n            print(A[-k])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc340_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    D = int(data[2])\n    \n    if D == 0:\n        print(A)\n    else:\n        n = (B - A) // D + 1\n        print(' '.join(str(A + i * D) for i in range(n)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc341_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Parse initial amounts\n    A = list(map(int, data[1:1+n]))\n    \n    # Parse constraints\n    constraints = []\n    idx = 1 + n\n    for i in range(n-1):\n        s = int(data[idx]); t = int(data[idx+1])\n        idx += 2\n        constraints.append((s, t))\n    \n    # DP table: dp[i][j] = max amount of country i after using j operations\n    dp = [[0] * (n+1) for _ in range(n)]\n    \n    # Initialize with initial amounts\n    for i in range(1, n+1):\n        dp[i][0] = A[i-1]\n    \n    # Process constraints from last to first\n    for s, t in reversed(constraints):\n        new_dp = [[0] * (n+1) for _ in range(n)]\n        for i in range(1, n+1):\n            for j in range(i):  # Use up to j operations\n                new_dp[i][j] = dp[i][j]\n            for k in range(1, n+1):\n                if i == k:\n                    continue\n                cost = min(s, dp[i][j])\n                if cost > 0:\n                    new_dp[k][j+1] = max(new_dp[k][j+1], dp[i][j] - cost + t)\n                else:\n                    new_dp[k][j+1] = max(new_dp[k][j+1], dp[i][j])\n        dp = new_dp\n    \n    print(dp[n][n])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc341_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    N = int(data[0])\n    \n    result = []\n    for i in range(N):\n        if i % 2 == 0:\n            result.append('0')\n        else:\n            result.append('1')\n            \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc342_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    s = list(data)\n    \n    # Find the position of the differing character (excluding the last one)\n    for i in range(len(s) - 1):\n        if s[i] != s[-1]:\n            result = i + 1\n            break\n            \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc342_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    p = list(map(int, data[1:1+n]))\n    \n    q = int(data[1+n])\n    queries = []\n    idx = 1 + n + 1\n    for _ in range(q):\n        a = int(data[idx]); b = int(data[idx+1])\n        queries.append((a, b))\n        idx += 2\n    \n    # Build adjacency list\n    adj = [[] for _ in range(n+1)]\n    for i in range(1, n+1):\n        if p[i] != i:\n            adj[p[i]].append(i)\n    \n    results = []\n    for a, b in queries:\n        current = a\n        while True:\n            next_pos = -1\n            for neighbor in adj[current]:\n                if neighbor > current and neighbor <= b:\n                    next_pos = neighbor\n                    break\n            if next_pos == -1:\n                break\n            current = next_pos\n        results.append(str(current))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc343_a",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if len(data) != 2:\n        return\n    \n    A = int(data[0])\n    B = int(data[1])\n    \n    result = [i for i in range(10) if i != A + B]\n    print(result[0])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc343_b",
    "model": "diverse_instruction_checkpoint-300",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    \n    # Build adjacency list\n    adj_list = [[] for _ in range(N+1)]\n    idx = 1\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            if int(data[idx]) == 1:\n                adj_list[i].append(j)\n                adj_list[j].append(i)\n            idx += 1\n    \n    # Print results\n    for i in range(1, N+1):\n        print(' '.join(map(str, sorted(adj_list[i]))))\n\nif __name__ == \"__main__\":\n    main()"
  }
]