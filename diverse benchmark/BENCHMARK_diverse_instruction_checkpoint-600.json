[
  {
    "id": "abc301_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    s = data[1]\n    \n    takahashi_wins = 0\n    aoki_wins = 0\n    \n    for i, char in enumerate(s):\n        if char == 'T':\n            takahashi_wins += 1\n        else:\n            aoki_wins += 1\n            \n        if takahashi_wins > aoki_wins:\n            break\n        elif aoki_wins > takahashi_wins:\n            continue\n        else:\n            # If tied, check which player reached this tie first\n            if i + 1 < n and s[i] != s[i+1]:\n                # Player with different next game state reached tie first\n                if s[i] == 'T':\n                    break\n                else:\n                    continue\n            else:\n                # Same next game state - take the one who was first to reach this tie\n                if i + 1 < n and s[i] != s[i+1]:\n                    break\n                else:\n                    # Both players reached this tie at the same time\n                    if i + 1 < n and s[i] != s[i+1]:\n                        break\n                    else:\n                        # This should not happen per problem constraints\n                        pass\n    \n    if takahashi_wins > aoki_wins:\n        print('T')\n    else:\n        print('A')\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "id": "abc301_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    A = list(map(int, data[1:1+N]))\n    \n    while True:\n        found = False\n        for i in range(N-1):\n            if abs(A[i] - A[i+1]) != 1:\n                # Find the segment with non-adjacent elements\n                left_start = min(A[i], A[i+1])\n                right_end = max(A[i], A[i+1])\n                \n                # Insert all numbers between left_start and right_end\n                # but exclude the original adjacent pair\n                for x in range(left_start + 1, right_end):\n                    A.insert(i+1, x)\n                del A[i+2]\n                found = True\n                break\n                \n        if not found:\n            print(' '.join(map(str, A)))\n            return\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc302_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    \n    if B >= A:\n        print(0)\n        return\n        \n    count = 0\n    while True:\n        count += 1\n        A -= B\n        if A <= 0:\n            break\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc303_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    grid = []\n    index = 2\n    for i in range(m):\n        row = list(map(int, data[index:index+n]))\n        grid.append(row)\n        index += n\n        \n    # Precompute prefix sums for each column\n    prefix_sum = [[0] * (n+1) for _ in range(n)]\n    for j in range(n):\n        for i in range(1, m+1):\n            prefix_sum[i][j+1] = prefix_sum[i-1][j+1] + grid[i-1][j]\n            \n    count = 0\n    # Check all pairs of columns\n    for j1 in range(n):\n        for j2 in range(j1+1, n):\n            total = 0\n            for i in range(1, m+1):\n                total += grid[i-1][j1] * grid[i-1][j2]\n            count += total - prefix_sum[i][j1] * prefix_sum[i][j2]\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc303_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index]); index += 1\n        s = data[index]; index += 1\n        t = data[index]; index += 1\n        \n        # Check if lengths match\n        if len(s) != len(t):\n            print(\"No\")\n            continue\n            \n        # Count mismatches\n        mismatch_count = 0\n        for i in range(n):\n            char_s = s[i]\n            char_t = t[i]\n            \n            # Check if both characters are identical\n            if char_s == char_t:\n                continue\n                \n            # Check similarity based on character types\n            if (char_s == 'l' and char_t == 'o') or (char_s == 'o' and char_t == 'l'):\n                # Both are 'l'/'o', so they're similar\n                continue\n                \n            if (char_s == '0' and char_t == 'o') or (char_s == 'o' and char_t == '0'):\n                # Both are '0'/'o', so they're similar  \n                continue\n                \n            if (char_s == '1' and char_t == 'o') or (char_s == 'o' and char_t == '1'):\n                # Both are '1'/'o', so they're similar\n                continue\n                \n            if (char_s == '0' and char_t == '1') or (char_s == '1' and char_t == '0'):\n                # Both are '0'/'1', so they're similar\n                continue\n                \n            # If none of the above, they're not similar\n            mismatch_count += 1\n            \n        if mismatch_count == 0:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc304_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    people = []\n    for i in range(n):\n        s = data[2*i + 1]\n        a = int(data[2*i + 2])\n        people.append((s, a))\n    \n    # Sort by age descending, then by name ascending\n    sorted_people = sorted(people, key=lambda x: (-x[1], x[0]))\n    \n    for name, _ in sorted_people:\n        print(name)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc304_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    n = int(data)\n    \n    if n <= 10**3 - 1:\n        print(n)\n    elif n <= 10**4 - 1:\n        print(str(n)[0:-1])\n    elif n <= 10**5 - 1:\n        print(str(n)[0:-2])\n    elif n <= 10**6 - 1:\n        print(str(n)[0:-3])\n    elif n <= 10**7 - 1:\n        print(str(n)[0:-4])\n    elif n <= 10**8 - 1:\n        print(str(n)[0:-5])\n    else:\n        print(str(n)[0:-6])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc305_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    \n    # Calculate positions of water stations\n    water_positions = []\n    current_pos = 0\n    while current_pos <= N:\n        water_positions.append(current_pos)\n        current_pos += 5\n    \n    # Handle case where we're already at a water station\n    if N in water_positions:\n        print(N)\n        return\n    \n    # Find closest water station\n    min_distance = float('inf')\n    for pos in water_positions:\n        if abs(pos - N) < min_distance:\n            min_distance = abs(pos - N)\n    \n    print(min_distance)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc305_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    p = data[0]\n    q = data[1]\n    \n    if p == 'A':\n        if q == 'B':\n            print(3)\n        elif q == 'C':\n            print(1)\n        elif q == 'D':\n            print(4)\n        elif q == 'E':\n            print(1)\n        elif q == 'F':\n            print(5)\n        else:  # q == 'G'\n            print(9)\n            \n    elif p == 'B':\n        if q == 'C':\n            print(1)\n        elif q == 'D':\n            print(4)\n        elif q == 'E':\n            print(1)\n        elif q == 'F':\n            print(5)\n        else:  # q == 'G'\n            print(9)\n            \n    elif p == 'C':\n        if q == 'D':\n            print(4)\n        elif q == 'E':\n            print(1)\n        elif q == 'F':\n            print(5)\n        else:  # q == 'G'\n            print(9)\n            \n    elif p == 'D':\n        if q == 'E':\n            print(1)\n        elif q == 'F':\n            print(5)\n        else:  # q == 'G'\n            print(9)\n            \n    elif p == 'E':\n        if q == 'F':\n            print(5)\n        else:  # q == 'G'\n            print(9)\n            \n    elif p == 'F':\n        if q == 'G':\n            print(9)\n        else:  # q == 'A' or 'B'\n            print(10)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc306_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = data[1]\n    \n    result = []\n    for char in S:\n        result.append(char)\n        result.append(char)\n        \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc306_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = list(map(int, data))\n    \n    result = 0\n    for i in range(64):\n        power = 2 ** (63 - i)\n        if A[i] == 1:\n            result += power\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc307_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    steps_list = list(map(int, data[1:1+N*7]))\n    \n    total_steps_per_week = []\n    current_sum = 0\n    for i in range(0, len(steps_list), 7):\n        week_steps = sum(steps_list[i:i+7])\n        total_steps_per_week.append(week_steps)\n        current_sum += week_steps\n        \n    print(\" \".join(map(str, total_steps_per_week)))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc307_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    strings = []\n    index = 1\n    for i in range(n):\n        s = data[index]\n        index += 1\n        strings.append(s)\n    \n    # Check all pairs (i, j) with i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            s1 = strings[i]\n            s2 = strings[j]\n            \n            # Concatenate in both orders\n            concat1 = s1 + s2\n            concat2 = s2 + s1\n            \n            # Check if either is a palindrome\n            def is_palindrome(s):\n                return s == s[::-1]\n            \n            if is_palindrome(concat1) or is_palindrome(concat2):\n                print(\"Yes\")\n                return\n                \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc308_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    S = list(map(int, data))\n    \n    # Check all three conditions\n    non_decreasing = True\n    for i in range(1, 8):\n        if S[i] < S[i-1]:\n            non_decreasing = False\n    \n    all_between = True\n    min_val = min(S)\n    max_val = max(S)\n    for val in S:\n        if not (100 <= val <= 675):\n            all_between = False\n        if not (val % 25 == 0):\n            all_between = False\n    \n    all_multiples_of_25 = True\n    for val in S:\n        if val % 25 != 0:\n            all_multiples_of_25 = False\n    \n    if non_decreasing and all_between and all_multiples_of_25:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc308_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    colors = []\n    for i in range(n):\n        colors.append(data[2 + 2*i])\n    \n    dishes = []\n    for i in range(m):\n        dishes.append(data[2 + 2*n + 2*i])\n    \n    prices = list(map(int, data[2 + 2*n + 2*m]))\n    \n    dish_to_price = {}\n    for i in range(m):\n        dish_to_price[dishes[i]] = prices[i]\n    \n    total_cost = 0\n    for color in colors:\n        if color in dish_to_price:\n            total_cost += dish_to_price[color]\n        else:\n            total_cost += 0\n    \n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc309_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    \n    # Define the 3x3 grid\n    grid = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    \n    # Find the row and column of square A\n    for i in range(3):\n        for j in range(3):\n            if grid[i][j] == A:\n                # Check if B is in the same row but different column\n                if grid[i][j+1] == B:\n                    print(\"Yes\")\n                    return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc309_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    grid = []\n    index = 1\n    for i in range(N):\n        row = list(map(int, data[index:index+N]))\n        grid.append(row)\n        index += N\n        \n    # Create original grid as string for easier manipulation\n    orig_str = ''\n    for row in grid:\n        orig_str += ''.join(str(x) for x in row)\n    \n    # Find positions of all non-zero elements\n    pos = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                pos.append((i+1, j+1))  # Convert to 1-based indexing\n    \n    # If no non-zero elements, output unchanged\n    if not pos:\n        print(orig_str)\n        return\n        \n    # Sort positions by row then by column\n    pos.sort(key=lambda p: (p[0], p[1]))\n    \n    # Extract coordinates\n    rows = [p[0] for p in pos]\n    cols = [p[1] for p in pos]\n    \n    # Calculate shifts needed\n    shift_rows = [r - 1 for r in rows]\n    shift_cols = [c - 1 for c in cols]\n    \n    # Apply shifts\n    result = []\n    for i in range(N):\n        row = []\n        for j in range(N):\n            if i + 1 in rows and j + 1 in cols:\n                row.append('0')\n            else:\n                row.append('1')\n        result.append(''.join(row))\n    \n    # Output the result\n    print('\\n'.join(result))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "id": "abc310_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    P = int(data[1])\n    Q = int(data[2])\n    \n    prices = list(map(int, data[3:3+N]))\n    \n    # If we don't use the coupon, the minimum cost is just the sum of all dishes\n    min_cost_no_coupon = sum(prices)\n    \n    # If we use the coupon, we need to find the best dish to order with the coupon\n    # The cost would be Q + sum of remaining dishes\n    # But since we want the minimum total payment, we should consider ordering the cheapest dish first\n    # because the coupon gives us more flexibility\n    \n    # We'll sort the dishes by price and try different combinations\n    # Since N <= 100, we can iterate over all possible subsets\n    import itertools\n    \n    min_total = float('inf')\n    \n    # Generate all non-empty subsets\n    for r in range(1, len(prices) + 1):\n        for subset in itertools.combinations(prices, r):\n            total_without_coupon = sum(subset)\n            cost_with_coupon = Q + total_without_coupon\n            if cost_with_coupon < min_total:\n                min_total = cost_with_coupon\n    \n    result = min(min_cost_no_coupon, min_total)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc310_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    prices = []\n    functions = []\n    \n    idx = 2\n    for i in range(n):\n        p = int(data[idx]); idx += 1\n        c = int(data[idx]); idx += 1\n        f_list = list(map(int, data[idx:idx+c]))\n        idx += c\n        prices.append(p)\n        functions.append(f_list)\n    \n    # Precompute prefix sums for each function\n    prefix_sum = [[] for _ in range(m+1)]\n    for func in range(1, m+1):\n        for price in prices:\n            prefix_sum[func].append(price + prefix_sum[func][-1] if prefix_sum[func] else price)\n    \n    # Check all pairs\n    found = False\n    for i in range(n):\n        for j in range(i+1, n):\n            pi = prices[i]\n            pj = prices[j]\n            \n            # Check if prices are equal\n            if pi != pj:\n                continue\n                \n            # Check if functions match exactly\n            if len(functions[i]) != len(functions[j]):\n                continue\n                \n            # Compare sets of functions\n            set_i = set(functions[i])\n            set_j = set(functions[j])\n            if set_i == set_j:\n                found = True\n                break\n            \n            # If not exact match, check if i has at least the missing functions\n            if len(set_i - set_j) > 0:\n                found = True\n                break\n    \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc311_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    s = data[1]\n    \n    count_A = 0\n    count_B = 0\n    count_C = 0\n    \n    for char in s:\n        if char == 'A':\n            count_A += 1\n        elif char == 'B':\n            count_B += 1\n        else:  # char == 'C'\n            count_C += 1\n            \n        if count_A > 0 and count_B > 0 and count_C > 0:\n            print(n)\n            return\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc311_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    d = int(data[1])\n    \n    schedules = []\n    index = 2\n    for i in range(n):\n        schedules.append(data[index:index+d])\n        index += d\n    \n    # Precompute prefix sum for each person\n    prefix = [[0] * (d+1) for _ in range(n)]\n    for i in range(n):\n        for j in range(d):\n            prefix[i][j+1] = prefix[i][j] + (1 if schedules[i][j] == 'o' else 0)\n    \n    max_days = 0\n    \n    # Try all starting positions\n    for start in range(d):\n        # Try all lengths up to remaining days\n        for length in range(start, d+1):\n            if length > d - start:\n                break\n                \n            # Check if this window is valid\n            valid = True\n            for i in range(n):\n                if prefix[i][start+length] - prefix[i][start] != 0:\n                    valid = False\n                    break\n            \n            if valid:\n                max_days = max(max_days, length)\n    \n    print(max_days)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc312_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    s = input().strip()\n    \n    # Define all target strings\n    targets = [\"ACE\", \"BDF\", \"CEG\", \"DFA\", \"EGB\", \"FAC\", \"GBD\"]\n    \n    # Check if s matches any target\n    for target in targets:\n        if s == target:\n            print(\"Yes\")\n            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc312_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    m = int(data[1])\n    \n    grid = []\n    index = 2\n    for i in range(n):\n        grid.append(data[index:index+m])\n        index += m\n    \n    def is_tak_code(i, j):\n        # Check top-left 3x3\n        if grid[i][j] != '#':\n            return False\n        if grid[i+1][j] != '#' or grid[i+2][j] != '#' or \\\n           grid[i][j+1] != '#' or grid[i+1][j+1] != '#' or grid[i+2][j+1] != '#' or \\\n           grid[i][j+2] != '#' or grid[i+1][j+2] != '#' or grid[i+2][j+2] != '#':\n            return False\n        \n        # Check bottom-right 3x3  \n        if grid[i][j] != '#':\n            return False\n        if grid[i+1][j] != '.' or grid[i+2][j] != '.' or \\\n           grid[i][j+1] != '.' or grid[i+1][j+1] != '.' or grid[i+2][j+1] != '.' or \\\n           grid[i][j+2] != '.' or grid[i+1][j+2] != '.' or grid[i+2][j+2] != '.':\n            return False\n        \n        # Check adjacency between top-left and bottom-right\n        for di in [-1, 0, 1]:\n            for dj in [-1, 0, 1]:\n                ni, nj = i + di, j + dj\n                if ni < 0 or ni >= n or nj < 0 or nj >= m:\n                    continue\n                if (ni == i and nj == j) or (abs(di) + abs(dj) != 1):\n                    continue\n                if grid[ni][nj] != '.':\n                    return False\n        \n        return True\n    \n    result = []\n    for i in range(n - 8):\n        for j in range(m - 8):\n            if is_tak_code(i, j):\n                result.append(f\"{i} {j}\")\n    \n    print(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc313_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    scores = list(map(int, data[1:1+n]))\n    \n    min_score = min(scores)\n    result = max(0, min_score - 1)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc314_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    \n    # Precomputed value for N=100 (as per problem constraints)\n    pi_str = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\"\n    \n    # Truncate to N decimal places\n    truncated_pi = float(pi_str[:N+1])\n    \n    print(f\"{truncated_pi:.{N}f}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc314_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    \n    results = []\n    for _ in range(t):\n        N = int(data[0])\n        C_list = list(map(int, data[1:1+N]))\n        \n        # Create list of (bet_count, original_index) pairs\n        bets = []\n        for idx, C in enumerate(C_list):\n            bets.append((C, idx))\n        \n        # Sort by bet count descending, then by original index ascending\n        bets.sort(key=lambda x: (-x[0], x[1]))\n        \n        # Find the minimum bet count\n        min_bet = None\n        for _, idx in bets:\n            if min_bet is None or idx < min_bet:\n                min_bet = idx\n        \n        # Collect indices where bet count equals min_bet\n        selected_indices = [idx for _, idx in bets if idx == min_bet]\n        \n        # Collect corresponding original indices\n        result_indices = []\n        for idx in selected_indices:\n            result_indices.append(idx + 1)\n        \n        results.append(f\"{len(result_indices)} {' '.join(map(str, result_indices))}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc315_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    M = int(data[0])\n    D = list(map(int, data[1:1+M]))\n    \n    total_days = sum(D)\n    middle_day_index = (total_days + 1) // 2\n    \n    current_day = 1\n    month = 1\n    day_in_month = 1\n    \n    for d in D:\n        while current_day <= middle_day_index and day_in_month <= d:\n            current_day += 1\n            day_in_month += 1\n        \n        if current_day > middle_day_index:\n            break\n            \n        month += 1\n        day_in_month = 1\n    \n    print(f\"{month} {current_day}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc315_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    s = data[0].strip()\n    \n    # Remove vowels using list comprehension\n    result = ''.join([char for char in s if char not in 'aeiou'])\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc318_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    total_area = 0\n    \n    for i in range(n):\n        a = int(data[2*i + 1])\n        b = int(data[2*i + 2])\n        c = int(data[2*i + 3])\n        d = int(data[2*i + 4])\n        \n        # Calculate horizontal extent: min(b, 100) - max(a, 0)\n        h_min = max(0, b)\n        h_max = min(100, a)\n        horizontal_extent = h_min - h_max\n        \n        # Calculate vertical extent: min(d, 100) - max(c, 0)\n        v_min = max(0, d)\n        v_max = min(100, c)\n        vertical_extent = v_min - v_max\n        \n        if horizontal_extent > 0 and vertical_extent > 0:\n            total_area += horizontal_extent * vertical_extent\n            \n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc318_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    M = int(data[1])\n    P = int(data[2])\n    \n    if M > N:\n        print(0)\n        return\n        \n    count = 0\n    i = M\n    \n    while i <= N:\n        if (i - M) % P == 0:\n            count += 1\n        i += 1\n        \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc319_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    \n    # Precompute all divisors of N\n    divisors = []\n    for i in range(1, 10):\n        if N % i == 0:\n            divisors.append(i)\n    \n    result = []\n    for i in range(N + 1):\n        found = False\n        for d in divisors:\n            if d <= 9 and i % (N // d) == 0:\n                result.append(str(d))\n                found = True\n                break\n        if not found:\n            result.append('-')\n    \n    print(''.join(result))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "id": "abc320_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    n = len(data)\n    \n    # Precompute prefix sums for character counts\n    prefix = [[0] * 26 for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(26):\n            prefix[i][j] = prefix[i-1][j] + (1 if data[i-1] == chr(ord('A') + j) else 0)\n    \n    max_len = 0\n    \n    # Try all possible lengths k from 1 to n\n    for k in range(1, n+1):\n        # Check all starting positions where we can have a palindrome of length k\n        for start in range(n - k + 1):\n            count = prefix[start+k] - prefix[start]\n            if count >= k:\n                max_len = max(max_len, k)\n    \n    print(max_len)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc320_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    \n    result = (pow(A, B) + pow(B, A))\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc321_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    x = int(data[1])\n    \n    scores = list(map(int, data[2:2+n-1]))\n    \n    # Sort the scores\n    sorted_scores = sorted(scores)\n    \n    total_sum = sum(sorted_scores)\n    \n    # Calculate the sum of middle N-2 elements\n    min_grade = float('inf')\n    for k in range(1, n-1):\n        min_grade = min(min_grade, total_sum - sorted_scores[k] * (n-2))\n    \n    if min_grade >= x:\n        print(min_grade)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc321_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    t = int(data[0])\n    \n    for i in range(1, t + 1):\n        n_str = data[i].strip()\n        n_len = len(n_str)\n        \n        # Check if number length is too large\n        if n_len > 5:\n            print(\"No\")\n            continue\n            \n        # Convert to list of digits\n        digits = [int(d) for d in n_str]\n        \n        # Check each position: digit at index i should be greater than digit at index i+1\n        for i in range(n_len - 1):\n            if digits[i] <= digits[i + 1]:\n                print(\"No\")\n                break\n        else:\n            print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc322_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "t = int(input().strip())\nfor _ in range(t):\n    n = int(input().strip())\n    s = input().strip()\n    \n    for i in range(n - 2):\n        if s[i:i+3] == 'ABC':\n            print(i + 1)\n            break\n    else:\n        print(-1)"
  },
  {
    "id": "abc322_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    S = data[2]\n    T = data[3]\n    \n    if len(S) != N or len(T) != M:\n        print(3)\n        return\n        \n    if S == T[:N]:\n        print(1)\n        return\n        \n    if S == T[-N:]:\n        print(2)\n        return\n        \n    print(0)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc323_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    results = []\n    for i in range(1, N + 1):\n        results.append(''.join(data[i:i+N]))\n    \n    # Count wins for each player\n    wins = [0] * (N + 1)\n    for i in range(N):\n        for j in range(i + 1, N):\n            if results[i][j] == 'o':\n                wins[i + 1] += 1\n                wins[j + 1] -= 1\n            elif results[i][j] == 'x':\n                wins[i + 1] -= 1\n                wins[j + 1] += 1\n    \n    # Sort by wins descending, then by player number ascending\n    sorted_indices = sorted(range(1, N + 1), key=lambda idx: (-wins[idx], idx))\n    print(' '.join(map(str, sorted_indices)))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "id": "abc323_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    s = data[0].strip()\n    \n    # Check if all even positions have '0'\n    for i in range(1, 17, 2):\n        if s[i] != '0':\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc324_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    first_val = arr[0]\n    for val in arr:\n        if val != first_val:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc324_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Check divisibility by 2\n    while n % 2 == 0:\n        n //= 2\n    \n    # Check divisibility by 3\n    while n % 3 == 0:\n        n //= 3\n    \n    # If n becomes 1, it's possible (all factors were removed)\n    # If n remains greater than 1, impossible\n    if n == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc325_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    S = data[0]\n    T = data[1]\n    print(f\"{S} {T} san\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc326_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    \n    # Find the smallest multiple of 10 that is >= N\n    remainder = N % 10\n    if remainder == 0:\n        start = N\n    else:\n        start = (N // 10 + 1) * 10\n    \n    # Check each multiple of 10 starting from ceil(N/10)*10\n    for num in range(start, N+1):\n        hundreds = num // 100\n        tens = (num // 10) % 10\n        ones = num % 10\n        if hundreds * tens == ones:\n            print(num)\n            return\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc326_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    X = int(data[0])\n    Y = int(data[1])\n    \n    # Check if both floors are even or both are odd\n    if (X % 2 == 0) ^ (Y % 2 == 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc327_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if len(data) < 2:\n        return\n    \n    n = int(data[0])\n    s = data[1]\n    \n    for i in range(n - 1):\n        if s[i] == 'a' and s[i + 1] == 'b':\n            print(\"Yes\")\n            return\n        elif s[i] == 'b' and s[i + 1] == 'a':\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc327_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    B = int(data[0])\n    \n    # Check for small cases first to avoid overflow\n    if B == 1:\n        print(1)\n        return\n        \n    if B < 4:\n        print(-1)\n        return\n        \n    # For large B, use logarithmic approach\n    log_val = (B + 1) ** (1/3)\n    \n    # Find all divisors up to sqrt(log_val)\n    divisors = []\n    i = 1\n    while i * i <= log_val:\n        if log_val % i == 0:\n            divisors.append(i)\n            if i != log_val // i:\n                divisors.append(log_val // i)\n        i += 1\n    \n    # Remove duplicates and sort\n    divisors.sort()\n    unique_divisors = list(set(divisors))\n    \n    # Check each divisor\n    for d in unique_divisors:\n        if d > 1 and B % d == 0:\n            root_d = d ** (d - 1)\n            if root_d == B:\n                print(d)\n                return\n                \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc328_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    D = list(map(int, data[1:1+N]))\n    \n    count = 0\n    \n    # Iterate through each month\n    for i in range(1, N + 1):\n        # Iterate through each day in the current month\n        for j in range(1, D[i - 1] + 1):\n            # Convert month and day to strings\n            month_str = str(i).zfill(2)\n            day_str = str(j).zfill(2)\n            \n            # Check if both have same digit sum\n            def digit_sum(s):\n                return sum(int(d) for d in s)\n            \n            if digit_sum(month_str) == digit_sum(day_str):\n                count += 1\n                \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc328_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    X = int(data[1])\n    \n    scores = list(map(int, data[2:2+N]))\n    \n    total_score = sum(scores)\n    \n    if total_score <= X:\n        print(total_score)\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc329_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    for char in data:\n        print(char, end=' ')\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc329_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    max_val = max(arr)\n    result = None\n    \n    for num in arr:\n        if num != max_val and (result is None or num > result):\n            result = num\n            \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc330_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    L = int(data[idx]); idx += 1\n    R = int(data[idx]); idx += 1\n    \n    A = []\n    for _ in range(N):\n        A.append(int(data[idx])); idx += 1\n        \n    # Precompute prefix sums\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i-1] + A[i-1]\n    \n    # Precompute suffix sums  \n    suffix_sum = [0] * (N + 1)\n    for i in range(N-1, -1, -1):\n        suffix_sum[i] = suffix_sum[i+1] + A[i]\n    \n    results = []\n    for i in range(N):\n        left_sum = prefix_sum[i]\n        right_sum = suffix_sum[i+1]\n        \n        min_diff = float('inf')\n        best_X = None\n        \n        for x in range(L, R + 1):\n            diff = abs(x - A[i])\n            if diff < min_diff or (diff == min_diff and x < best_X):\n                min_diff = diff\n                best_X = x\n                \n        results.append(str(best_X))\n    \n    print(\" \".join(results))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc330_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    l = int(data[1])\n    \n    scores = list(map(int, data[2:2+n]))\n    \n    count_passed = sum(1 for score in scores if score >= l)\n    \n    print(count_passed)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc331_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    M, D = map(int, data[0:2])\n    y, m, d = map(int, data[2:])\n    \n    total_days_in_year = M * D\n    \n    if d < total_days_in_year:\n        next_day = d + 1\n    else:\n        next_month = (m + 1) % M\n        next_day = 1\n        \n        if next_month == 0:\n            next_month = M\n            next_year = y + 1\n        else:\n            next_year = y\n            \n    print(f\"{next_year} {next_month} {next_day}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc331_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = int(data[1])\n    M = int(data[2])\n    L = int(data[3])\n    \n    # Precompute prefix sums for each pack size\n    prefix_S = [0] * (N + 1)\n    prefix_M = [0] * (N + 1)\n    prefix_L = [0] * (N + 1)\n    \n    for i in range(1, N + 1):\n        prefix_S[i] = prefix_S[i - 1] + S\n        prefix_M[i] = prefix_M[i - 1] + M\n        prefix_L[i] = prefix_L[i - 1] + L\n    \n    # DP table: dp[i][j] = min cost to get j eggs with first i packs\n    INF = 10**9\n    dp = [[INF] * (N + 1) for _ in range(N + 1)]\n    \n    # Base case: no packs, 0 eggs\n    dp[0][0] = 0\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(0, N + 1):\n            if dp[i-1][j] != INF:\n                # Option 1: don't use this pack\n                dp[i][j] = min(dp[i][j], dp[i-1][j])\n                \n                # Option 2: use one 6-egg pack\n                if j >= 6:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-6] + S)\n                \n                # Option 3: use one 8-egg pack  \n                if j >= 8:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-8] + M)\n                \n                # Option 4: use one 12-egg pack\n                if j >= 12:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-12] + L)\n    \n    # Find minimum cost to get at least N eggs\n    result = INF\n    for j in range(N, 0, -1):\n        result = min(result, dp[N][j])\n    \n    print(result)\n\nif __name__ =="
  },
  {
    "id": "abc332_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    s = int(data[1])\n    k = int(data[2])\n    \n    prices = []\n    quantities = []\n    idx = 3\n    for i in range(n):\n        p = int(data[idx])\n        q = int(data[idx + 1])\n        prices.append(p)\n        quantities.append(q)\n        idx += 2\n    \n    total_price = sum(p * q for p, q in zip(prices, quantities))\n    \n    if total_price >= s:\n        shipping_fee = 0\n    else:\n        shipping_fee = k\n    \n    result = total_price + shipping_fee\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc332_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    K = int(data[0])\n    G = int(data[1])\n    M = int(data[2])\n    \n    glass = 0\n    mug = 0\n    \n    for _ in range(K):\n        # If glass is empty, fill it\n        if glass == 0:\n            glass = G\n        \n        # If mug is empty, fill it\n        elif mug == 0:\n            mug = M\n            \n        else:\n            # Transfer water from mug to glass until either glass is full or mug is empty\n            while glass < G and mug > 0:\n                glass += 1\n                mug -= 1\n                \n    print(f\"{glass} {mug}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc333_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    S1, S2 = data[0], data[1]\n    T1, T2 = data[2], data[3]\n    \n    # Pentagonal vertices: A(0,1), B(1,0), C(-1/2, sqrt(3)/2), D(-1/2, -sqrt(3)/2), E(1/2, 0)\n    # Coordinates for each vertex\n    A = (0, 1)\n    B = (1, 0)\n    C = (-1/2, math.sqrt(3)/2)\n    D = (-1/2, -math.sqrt(3)/2)\n    E = (1/2, 0)\n    \n    def distance(p1, p2):\n        return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)\n    \n    def get_midpoint(p1, p2):\n        return ((p1[0]+p2[0])/2, (p1[1]+p2[1])/2)\n    \n    S1_pos = (A if S1 == 'A' else B if S1 == 'B' else C if S1 == 'C' else D if S1 == 'D' else E) \n    S2_pos = (A if S2 == 'A' else B if S2 == 'B' else C if S2 == 'C' else D if S2 == 'D' else E)\n    T1_pos = (A if T1 == 'A' else B if T1 == 'B' else C if T1 == 'C' else D if T1 == 'D' else E)\n    T2_pos = (A if T2 == 'A' else B if T2 == 'B' else C if T2 == 'C' else D if T2 == 'D' else E)\n    \n    mid_S = get_midpoint(S1_pos, S2_pos)\n    mid_T = get_midpoint(T1_pos, T2_pos)\n    \n    dist_S = distance(mid_S, S1_pos)\n    dist_T = distance(mid_T, T1_pos)\n    \n    print(\"Yes\" if abs(dist_S - dist_T) < 1e-9 else \"No\")\n\nif __name__"
  },
  {
    "id": "abc333_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    N = int(data)\n    \n    # Create the concatenated string\n    result = str(N) * N\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc334_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    B = int(data[0])\n    G = int(data[1])\n    \n    if B > G:\n        print(\"Bat\")\n    else:\n        print(\"Glove\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc335_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    s = data[0].strip()\n    \n    # Find the position of the last '2' before the last '3'\n    last_2_pos = -1\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == '2':\n            last_2_pos = i\n            break\n    \n    # If no '2' found before '3', we need to find the last '2'\n    if last_2_pos == -1:\n        last_2_pos = len(s) - 1\n    \n    # Change the last character to '4'\n    result = s[:last_2_pos + 1] + '4' + s[last_2_pos + 2:]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc335_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    \n    # Generate triples using nested loops\n    for x in range(N + 1):\n        for y in range(N - x + 1):\n            for z in range(N - x - y + 1):\n                print(f\"{x} {y} {z}\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc336_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        N = int(data[index]); index += 1\n        result = \"L\"\n        for i in range(N):\n            result += \"o\" * i + \"n\" + \"g\"\n        results.append(result)\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc336_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    \n    # Find the highest power of 2 <= n\n    k = 0\n    while (1 << k) <= n:\n        k += 1\n    k -= 1\n    \n    # Calculate ctz(n) using the formula\n    result = k - (n & ((1 << k) - 1))\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc337_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().strip()\n    n = len(data)\n    \n    # Check if all characters are 'A'\n    if all(ch == 'A' for ch in data):\n        print(\"Yes\")\n        return\n    \n    # Check if all characters are 'B'\n    if all(ch == 'B' for ch in data):\n        print(\"Yes\")\n        return\n    \n    # Check if all characters are 'C'\n    if all(ch == 'C' for ch in data):\n        print(\"Yes\")\n        return\n    \n    # If none of the above checks work, we need to find triples\n    # This approach is too slow for large inputs - see optimized solution below\n    # For now, I'll implement a simpler strategy that works for small cases\n    \n    # Find all substrings of length 3\n    substrings = []\n    for i in range(n - 2):\n        substrings.append(data[i:i+3])\n    \n    # Check each substring to see if it's an Extended ABC string\n    for s in substrings:\n        if len(s) != 3:\n            continue\n            \n        # Try all three possible orders\n        for order in [(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]:\n            pos0, pos1, pos2 = order\n            if (data[pos0] == 'A' and data[pos1] == 'B' and data[pos2] == 'C') or \\\n               (data[pos0] == 'B' and data[pos1] == 'C' and data[pos2] == 'A') or \\\n               (data[pos0] == 'C' and data[pos1] == 'A' and data[pos2] == 'B'):\n                print(\"Yes\")\n                return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc337_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    takahashi_score = 0\n    aoki_score = 0\n    \n    idx = 1\n    for _ in range(n):\n        x_i = int(data[idx]); y_i = int(data[idx+1])\n        takahashi_score += x_i\n        aoki_score += y_i\n        idx += 2\n    \n    if takahashi_score > aoki_score:\n        print(\"Takahashi\")\n    elif aoki_score > takahashi_score:\n        print(\"Aoki\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc338_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    t = int(data[0])\n    \n    for i in range(1, t + 1):\n        s = data[i].strip()\n        \n        if not s:\n            continue\n            \n        # Check if first character is uppercase and rest are lowercase\n        if s[0].isupper() and all(c.islower() for c in s[1:]):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc338_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    s = data[0].strip()\n    \n    # Count frequencies using dictionary\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    \n    max_count = max(freq.values()) if freq else 0\n    \n    # Find all characters with maximum count\n    candidates = [char for char, cnt in freq.items() if cnt == max_count]\n    \n    # Sort alphabetically and pick first (earliest in alphabetical order)\n    candidates.sort()\n    result_char = candidates[0]\n    \n    print(result_char)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc339_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    s = data[0].strip()\n    \n    # Find all occurrences of \"..\"\n    dot_positions = []\n    for i in range(len(s)):\n        if s[i] == '.' and i + 1 < len(s) and s[i+1] == '.':\n            dot_positions.append(i)\n    \n    # If no \"..\", output empty string\n    if not dot_positions:\n        print(\"\")\n        return\n    \n    # Process each pair of dots (except last pair)\n    max_suffix = \"\"\n    for i in range(len(dot_positions) - 1):\n        j = dot_positions[i]\n        k = dot_positions[i+1]\n        \n        # Check if this segment has any dots\n        has_dots = False\n        for pos in range(j + 1, k):\n            if s[pos] == '.':\n                has_dots = True\n                break\n        \n        if not has_dots:\n            # This segment doesn't have any dots, so we can use it as suffix\n            suffix = s[j+1:k]\n            if len(suffix) > len(max_suffix):\n                max_suffix = suffix\n    \n    # If we found any non-empty suffix, output it; otherwise output empty string\n    if max_suffix:\n        print(max_suffix)\n    else:\n        print(\"\")\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc340_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    \n    # Precompute factorials up to 100000 (since 10^9 < 100000!)\n    max_n = 100000\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i\n    \n    results = []\n    idx = 1\n    for _ in range(t):\n        query_type = int(data[idx]); idx += 1\n        \n        if query_type == 1:\n            x = int(data[idx]); idx += 1\n            results.append(str(x))\n        \n        elif query_type == 2:\n            k = int(data[idx]); idx += 1\n            n = len(results)\n            position_from_end = n - k + 1\n            if position_from_end <= 0 or position_from_end > n:\n                results.append(\"0\")\n            else:\n                results.append(str(fact[position_from_end]))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc340_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    D = int(data[2])\n    \n    if D == 0:\n        print(A)\n    else:\n        n = (B - A) // D + 1\n        result = [str(A + i * D) for i in range(n)]\n        print(\" \".join(result))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc341_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Precompute prefix sums for A_i\n    prefix_A = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_A[i] = prefix_A[i - 1] + int(data[i])\n    \n    # Read operations\n    operations = []\n    idx = n + 1\n    for _ in range(n - 1):\n        s_val = int(data[idx]); t_val = int(data[idx + 1])\n        idx += 2\n        operations.append((s_val, t_val))\n    \n    # Process operations in reverse order (from last to first)\n    max_units = prefix_A[n]\n    for i in range(n - 1, 0, -1):\n        s_val, t_val = operations[i - 1]\n        max_units = max(max_units, prefix_A[i] + t_val)\n    \n    print(max_units)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc341_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    t = int(data[0])\n    \n    for i in range(1, t + 1):\n        N = int(data[i])\n        result = '1' + '0' * N\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc342_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    s = data[0].strip()\n    \n    # Find the position of the differing character (excluding the repeating ones)\n    diff_pos = None\n    for i, char in enumerate(s):\n        if char != s[0]:\n            diff_pos = i + 1  # Convert to 1-based indexing\n            break\n    \n    print(diff_pos)\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc342_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    p_list = list(map(int, data[1:1+n]))\n    \n    q = int(data[1+n])\n    queries = []\n    idx = 1 + n + 1\n    for i in range(q):\n        a = int(data[idx]); b = int(data[idx+1])\n        queries.append((a, b))\n        idx += 2\n    \n    # Precompute prefix sums for positions\n    prefix_pos = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_pos[i] = prefix_pos[i-1] + (p_list[i-1] - 1)\n    \n    results = []\n    for a, b in queries:\n        pos_a = prefix_pos[a-1]\n        pos_b = prefix_pos[b]\n        result = p_list[pos_a + (pos_b - pos_a)]\n        results.append(str(result))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc343_a",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    A = int(data[0])\n    B = int(data[1])\n    \n    result = [i for i in range(10) if i != A + B]\n    print(result[0])\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "id": "abc343_b",
    "model": "diverse_instruction_checkpoint-600",
    "code": "def main():\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    index = 1\n    \n    for _ in range(t):\n        N = int(data[index]); index += 1\n        A = []\n        for i in range(N):\n            row = list(map(int, data[index:index+N]))\n            index += N\n            A.append(row)\n        \n        result = []\n        for i in range(1, N+1):\n            neighbors = [j for j in range(1, N+1) if A[i-1][j-1] == 1]\n            result.append(' '.join(map(str, sorted(neighbors))))\n        \n        print('\\n'.join(result))\n\nif __name__ == \"__main__\":\n    main()"
  }
]